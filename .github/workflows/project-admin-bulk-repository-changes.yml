# =========================================================================================
# CAMARA Project - Bulk Repository Changes Workflow
#
# This GitHub Actions workflow executes administrative operations across multiple CAMARA
# repositories with filtering and parallel execution capabilities.
#
# CHANGELOG:
# - 2025-07-26: Initial version as is for r1.1 release of camaraproject/project-administration
# - 2025-07-28: Removed disable-wiki, add-changelog-codeowners, update-api-readiness-checklist; Added centralize-linting-workflows
#
# USAGE:
# - Manually triggered via workflow_dispatch
# - Supports repository filtering by category and name patterns
# - Always test with single repository first, then dry-run mode
# - Processes up to 5 repositories in parallel
#
# DOCUMENTATION:
# see https://github.com/camaraproject/project-administration/blob/main/documentation/project-admin-bulk-repository-adminstration.md
# =========================================================================================

name: Bulk Repository Changes

permissions:
  contents: write       # For CODEOWNERS file operations
  pull-requests: write  # For creating pull requests

on:
  workflow_dispatch:
    inputs:
      operation:
        description: 'Operation to perform'
        required: true
        type: choice
        options:
          - 'add-changelog-file'
          - 'update-swagger-links'
          - 'update-swagger-links-releases'
          - 'centralize-linting-workflows'
        default: 'centralize-linting-workflows'
      
      dry_run:
        description: 'Run in dry-run mode (no actual changes)'
        required: true
        type: boolean
        default: true
      
      # Repository Category Selection
      include_sandbox_repos:
        description: 'Include Sandbox API Repositories'
        required: false
        type: boolean
        default: true
      
      include_incubating_repos:
        description: 'Include Incubating API Repositories'
        required: false
        type: boolean
        default: true
      
      include_working_group_repos:
        description: 'Include Working Group Repositories'
        required: false
        type: boolean
        default: true
      
      include_other_repos:
        description: 'Include Other Repositories'
        required: false
        type: boolean
        default: true
      
      repository_filter:
        description: 'Repository name pattern (leave empty for all repos)'
        required: false
        type: string
        default: ''
      
      exclude_repos:
        description: 'Comma-separated list of repos to exclude'
        required: false
        type: string
        default: 'Governance,.github'
      
      commit_strategy:
        description: 'How to apply file changes (only applies to file-based operations)'
        required: false
        type: choice
        options:
          - 'pull-request'
          - 'direct-with-warning'
        default: 'pull-request'

jobs:
  get-repositories:
    runs-on: ubuntu-latest
    outputs:
      repositories: ${{ steps.get-repos.outputs.repositories }}
      total_count: ${{ steps.get-repos.outputs.total_count }}
    steps:
      - name: Get organization repositories
        id: get-repos
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.CAMARA_BULK_CHANGE_TOKEN || secrets.GITHUB_TOKEN }}
          script: |
            const org = 'camaraproject';
            const filterPattern = '${{ github.event.inputs.repository_filter }}';
            const excludeRepos = '${{ github.event.inputs.exclude_repos }}'.split(',').map(r => r.trim()).filter(r => r);
            
            // Category selection inputs
            const includeSandbox = ${{ fromJson(github.event.inputs.include_sandbox_repos) }};
            const includeIncubating = ${{ fromJson(github.event.inputs.include_incubating_repos) }};
            const includeWorkingGroup = ${{ fromJson(github.event.inputs.include_working_group_repos) }};
            const includeOther = ${{ fromJson(github.event.inputs.include_other_repos) }};
            
            console.log(`Getting repositories for organization: ${org}`);
            console.log(`Include categories: Sandbox=${includeSandbox}, Incubating=${includeIncubating}, WorkingGroup=${includeWorkingGroup}, Other=${includeOther}`);
            
            let allRepos = [];
            let page = 1;
            
            while (true) {
              const response = await github.rest.repos.listForOrg({
                org: org,
                type: 'all',
                sort: 'name',
                per_page: 100,
                page: page
              });
              
              if (response.data.length === 0) break;
              allRepos = allRepos.concat(response.data);
              page++;
            }
            
            // Function to categorize repository based on topics
            function categorizeRepository(topics) {
              if (topics.includes('sandbox-api-repository')) {
                return 'sandbox';
              } else if (topics.includes('incubating-api-repository')) {
                return 'incubating';
              } else if (topics.includes('workinggroup')) {
                return 'working-group';
              } else {
                return 'other';
              }
            }
            
            // Filter repositories based on criteria and categories
            let filteredRepos = [];
            let categoryCounts = { sandbox: 0, incubating: 0, 'working-group': 0, other: 0 };
            
            for (const repo of allRepos) {
              if (repo.archived) continue;
              if (excludeRepos.includes(repo.name)) continue;
              if (filterPattern && !repo.name.includes(filterPattern)) continue;
              
              const category = categorizeRepository(repo.topics || []);
              categoryCounts[category]++;
              
              let includeThisRepo = false;
              switch (category) {
                case 'sandbox': includeThisRepo = includeSandbox; break;
                case 'incubating': includeThisRepo = includeIncubating; break;
                case 'working-group': includeThisRepo = includeWorkingGroup; break;
                case 'other': includeThisRepo = includeOther; break;
              }
              
              if (includeThisRepo) {
                filteredRepos.push(repo);
              }
            }
            
            const repositories = filteredRepos.map(repo => ({
              name: repo.name,
              full_name: repo.full_name,
              default_branch: repo.default_branch,
              category: categorizeRepository(repo.topics || [])
            }));
            
            console.log(`Selected ${repositories.length} repositories for processing`);
            core.setOutput('repositories', JSON.stringify(repositories));
            core.setOutput('total_count', repositories.length);

  execute-changes:
    needs: get-repositories
    if: fromJson(needs.get-repositories.outputs.total_count) > 0
    strategy:
      matrix:
        repository: ${{ fromJson(needs.get-repositories.outputs.repositories) }}
      max-parallel: 5
      fail-fast: false
    uses: ./.github/workflows/project-admin-repository-worker.yml
    with:
      repository_name: ${{ matrix.repository.name }}
      repository_full_name: ${{ matrix.repository.full_name }}
      default_branch: ${{ matrix.repository.default_branch }}
      operation: ${{ github.event.inputs.operation }}
      dry_run: ${{ fromJson(github.event.inputs.dry_run) }}
      commit_strategy: ${{ github.event.inputs.commit_strategy }}
    secrets:
      CAMARA_BULK_CHANGE_TOKEN: ${{ secrets.CAMARA_BULK_CHANGE_TOKEN }}

  collect-results:
    needs: [get-repositories, execute-changes]
    if: always() && fromJson(needs.get-repositories.outputs.total_count) > 0
    runs-on: ubuntu-latest
    steps:
      - name: Download all result artifacts
        uses: actions/download-artifact@v4
        with:
          pattern: result-*
          path: artifacts/
          merge-multiple: true

      - name: Collect and summarize results
        uses: actions/github-script@v7
        with:
          script: |
            const repositories = JSON.parse('${{ needs.get-repositories.outputs.repositories }}');
            const operation = '${{ github.event.inputs.operation }}';
            const dryRun = ${{ fromJson(github.event.inputs.dry_run) }};
            const commitStrategy = '${{ github.event.inputs.commit_strategy }}' || 'N/A';
            
            console.log('Collecting results from artifacts...');
            
            const fs = require('fs');
            const path = require('path');
            
            // Emoji mapping for result types (centralized here)
            const emojiMap = {
              'success': '‚úÖ',
              'no-change': 'üìä', 
              'warning': '‚ö†Ô∏è',
              'would-action': 'üß™',
              'error': '‚ùå'
            };
            
            // Function to determine if result requires attention
            function requiresAttention(resultType) {
              return ['warning', 'error'].includes(resultType);
            }
            
            let results = [];
            let resultTypeCounts = {};
            
            // Special counters for centralize-linting operation
            let lintingStats = {
              newLintingSetup: 0,
              migratedFromLocal: 0,
              alreadyCentralized: 0,
              totalLegacyArtifactsRemoved: 0,
              workflowFiles: { megalinter: 0, spectral: 0 },
              configFiles: { spectral: 0, yamllint: 0, gherkin: 0 },
              lintFunctionDirs: 0
            };
            
            // Read result files from artifacts
            try {
              const artifactsDir = 'artifacts';
              if (fs.existsSync(artifactsDir)) {
                const files = fs.readdirSync(artifactsDir);
                console.log(`Found ${files.length} result files`);
                
                for (const file of files) {
                  if (file.endsWith('.json')) {
                    try {
                      const filePath = path.join(artifactsDir, file);
                      const resultData = JSON.parse(fs.readFileSync(filePath, 'utf8'));
                      
                      // Use the generalized result fields from worker
                      const resultType = resultData.result_type || 'unknown';
                      const details = resultData.details || 'No details available';
                      const emoji = emojiMap[resultType] || '‚ùì';
                      const requiresAttentionFlag = requiresAttention(resultType);
                      
                      resultTypeCounts[resultType] = (resultTypeCounts[resultType] || 0) + 1;
                      
                      const repoInfo = repositories.find(r => r.name === resultData.repository);
                      const category = repoInfo ? repoInfo.category : 'unknown';
                      
                      // Add PR/commit links to details if available
                      let detailsWithLinks = details;
                      if (resultData.pr_number && resultData.pr_url) {
                        detailsWithLinks += ` [PR #${resultData.pr_number}](${resultData.pr_url})`;
                      }
                      
                      // Process linting-specific statistics
                      if (operation === 'centralize-linting-workflows') {
                        const opStatus = resultData.operation_status || '';
                        if (opStatus === 'already-centralized' || opStatus === 'no-change') {
                          lintingStats.alreadyCentralized++;
                        } else if (opStatus === 'add-completed' || (opStatus === 'would-add' && !resultData.had_prior_linting)) {
                          lintingStats.newLintingSetup++;
                        } else if (opStatus === 'migrate-completed' || (opStatus === 'would-migrate' && resultData.had_prior_linting)) {
                          lintingStats.migratedFromLocal++;
                        }
                        
                        // Count legacy artifacts
                        if (resultData.legacy_artifacts && Array.isArray(resultData.legacy_artifacts)) {
                          lintingStats.totalLegacyArtifactsRemoved += resultData.legacy_artifacts.length;
                          
                          resultData.legacy_artifacts.forEach(artifact => {
                            if (artifact.includes('megalinter.yml')) lintingStats.workflowFiles.megalinter++;
                            if (artifact.includes('spectral_oas_lint.yml')) lintingStats.workflowFiles.spectral++;
                            if (artifact.includes('.spectral.yml')) lintingStats.configFiles.spectral++;
                            if (artifact.includes('.yamllint.yaml')) lintingStats.configFiles.yamllint++;
                            if (artifact.includes('.gherkin-lintrc')) lintingStats.configFiles.gherkin++;
                            if (artifact === 'lint_function') lintingStats.lintFunctionDirs++;
                          });
                        }
                      }
                      
                      results.push({
                        repository: resultData.repository,
                        category: category,
                        result_type: resultType,
                        details: detailsWithLinks,
                        emoji: emoji,
                        requires_attention: requiresAttentionFlag,
                        operation_status: resultData.operation_status || resultType,
                        action_taken: resultData.action_taken || 'unknown',
                        pr_url: resultData.pr_url || '',
                        pr_number: resultData.pr_number || '',
                        commit_sha: resultData.commit_sha || '',
                        // Linting-specific data
                        had_prior_linting: resultData.had_prior_linting || false,
                        legacy_artifacts_count: resultData.legacy_artifacts_count || 0,
                        legacy_artifacts: resultData.legacy_artifacts || []
                      });
                      
                    } catch (parseError) {
                      console.log(`Error parsing ${file}: ${parseError.message}`);
                      // Add error entry for failed parsing
                      const repoName = file.replace(/^result-/, '').replace(/\.json$/, '');
                      results.push({
                        repository: repoName,
                        category: 'unknown',
                        result_type: 'error',
                        details: `Failed to parse result file: ${parseError.message}`,
                        emoji: '‚ùå',
                        requires_attention: true,
                        operation_status: 'parse-error',
                        action_taken: 'failed',
                        pr_url: '',
                        pr_number: '',
                        commit_sha: ''
                      });
                      resultTypeCounts['error'] = (resultTypeCounts['error'] || 0) + 1;
                    }
                  }
                }
              }
            } catch (error) {
              console.log(`Error reading artifacts: ${error.message}`);
            }
            
            console.log(`Collected ${results.length} results`);
            
            // Generate report
            const timestamp = new Date().toISOString();
            const totalRepos = repositories.length;
            
            const reportLines = [
              '# CAMARA Bulk Repository Changes - Execution Report',
              '',
              `**Execution Time:** ${timestamp}`,
              `**Operation:** ${operation}`,
              `**Commit Strategy:** ${commitStrategy}`,
              `**Mode:** ${dryRun ? 'DRY RUN' : 'LIVE EXECUTION'}`,
              `**Total Repositories:** ${totalRepos}`,
              '',
              '## Result Type Summary',
              '',
              '| Result Type | Count | Percentage |',
              '|-------------|-------|------------|'
            ];
            
            for (const [resultType, count] of Object.entries(resultTypeCounts)) {
              const percentage = totalRepos > 0 ? ((count / totalRepos) * 100).toFixed(1) : '0.0';
              const emoji = emojiMap[resultType] || '‚ùì';
              reportLines.push(`| ${emoji} ${resultType} | ${count} | ${percentage}% |`);
            }
            
            reportLines.push('');
            
            // Add linting-specific summary if applicable
            if (operation === 'centralize-linting-workflows') {
              reportLines.push('## Linting Migration Summary');
              reportLines.push('');
              reportLines.push(`**Mode**: ${dryRun ? 'DRY RUN' : 'LIVE EXECUTION'}`);
              reportLines.push(`**Total API Repositories Processed**: ${totalRepos}`);
              reportLines.push(`**Successful Migrations**: ${resultTypeCounts['success'] || 0}`);
              reportLines.push(`**Failed Operations**: ${resultTypeCounts['error'] || 0}`);
              reportLines.push('');
              reportLines.push('### Migration Categories:');
              reportLines.push(`- **New Linting Setup**: ${lintingStats.newLintingSetup} repositories (no previous linting)`);
              reportLines.push(`- **Migrated from Local**: ${lintingStats.migratedFromLocal} repositories (replaced existing linting)`);
              reportLines.push(`- **Already Centralized**: ${lintingStats.alreadyCentralized} repositories (skipped - already using centralized workflows)`);
              reportLines.push(`- **Failed**: ${resultTypeCounts['error'] || 0} repositories (errors during migration)`);
              reportLines.push('');
              
              if (lintingStats.totalLegacyArtifactsRemoved > 0 || dryRun) {
                reportLines.push(`### Files ${dryRun ? 'To Be Removed' : 'Removed'} (across all repositories):`);
                reportLines.push(`- Workflow files: ${lintingStats.workflowFiles.megalinter} instances of megalinter.yml, ${lintingStats.workflowFiles.spectral} instances of spectral_oas_lint.yml`);
                reportLines.push(`- Lint functions: ${lintingStats.lintFunctionDirs} repositories had lint_function/ directories ${dryRun ? 'to be removed' : 'removed'}`);
                reportLines.push(`- Config files: ${lintingStats.configFiles.spectral} .spectral.yml, ${lintingStats.configFiles.yamllint} .yamllint.yaml, ${lintingStats.configFiles.gherkin} .gherkin-lintrc files ${dryRun ? 'to be removed' : 'removed'}`);
                reportLines.push('');
                reportLines.push(`### Files ${dryRun ? 'To Be Added' : 'Added'}:`);
                reportLines.push(`- spectral-oas-caller.yml: ${lintingStats.newLintingSetup + lintingStats.migratedFromLocal} repositories`);
                reportLines.push(`- pr_validation_caller.yml: ${lintingStats.newLintingSetup + lintingStats.migratedFromLocal} repositories`);
                reportLines.push('');
                
                if (dryRun) {
                  reportLines.push('**Note**: In dry-run mode, these numbers show what WOULD be changed. No actual PRs are created.');
                }
              }
              
              reportLines.push('');
            }
            
            reportLines.push('## Repository Results');
            reportLines.push('');
            reportLines.push('| Repository | Category | Result | Details |');
            reportLines.push('|------------|----------|--------|---------|');
            
            // Sort results: attention-required first, then by repository name
            results.sort((a, b) => {
              if (a.requires_attention && !b.requires_attention) return -1;
              if (!a.requires_attention && b.requires_attention) return 1;
              return a.repository.localeCompare(b.repository);
            });
            
            for (const result of results) {
              reportLines.push(`| ${result.repository} | ${result.category} | ${result.emoji} ${result.result_type} | ${result.details} |`);
            }
            
            reportLines.push('');
            
            // Add detailed linting results if applicable
            if (operation === 'centralize-linting-workflows') {
              const successfulMigrations = results.filter(r => 
                (r.operation_status === 'migrate-completed' || r.operation_status === 'would-migrate') && r.had_prior_linting
              );
              const newSetups = results.filter(r => 
                (r.operation_status === 'add-completed' || r.operation_status === 'would-add') && !r.had_prior_linting
              );
              const alreadyCentralized = results.filter(r => 
                r.operation_status === 'already-centralized' || (r.result_type === 'no-change' && r.details.includes('centralized'))
              );
              
              if (successfulMigrations.length > 0) {
                reportLines.push(`### ‚úÖ Successfully ${dryRun ? 'Would Migrate' : 'Migrated'} from Local Linting (${successfulMigrations.length} repositories)`);
                reportLines.push('');
                reportLines.push('| Repository | Removed Files | Added Workflows | PR |');
                reportLines.push('|------------|---------------|-----------------|-----|');
                
                for (const result of successfulMigrations) {
                  const removedFiles = result.legacy_artifacts.map(a => {
                    if (a.includes('megalinter.yml')) return 'megalinter.yml';
                    if (a.includes('spectral_oas_lint.yml')) return 'spectral_oas_lint.yml';
                    if (a === 'lint_function') return 'lint_function/';
                    if (a.includes('.spectral.yml')) return '.spectral.yml';
                    if (a.includes('.yamllint.yaml')) return '.yamllint.yaml';
                    if (a.includes('.gherkin-lintrc')) return '.gherkin-lintrc';
                    return a;
                  }).join(', ');
                  
                  const prInfo = result.pr_number ? `#${result.pr_number}` : (dryRun ? '-' : 'N/A');
                  reportLines.push(`| ${result.repository} | ${removedFiles} | ‚úÖ Both workflows | ${prInfo} |`);
                }
                reportLines.push('');
              }
              
              if (newSetups.length > 0) {
                reportLines.push(`### üÜï New Linting Setup (${newSetups.length} repositories)`);
                reportLines.push('');
                reportLines.push('| Repository | Previous State | Added Workflows | PR |');
                reportLines.push('|------------|----------------|-----------------|-----|');
                
                for (const result of newSetups) {
                  const prInfo = result.pr_number ? `#${result.pr_number}` : (dryRun ? '-' : 'N/A');
                  reportLines.push(`| ${result.repository} | No linting | ‚úÖ Both workflows | ${prInfo} |`);
                }
                reportLines.push('');
              }
              
              if (alreadyCentralized.length > 0) {
                reportLines.push(`### ‚è≠Ô∏è Already Centralized (${alreadyCentralized.length} repositories)`);
                reportLines.push('');
                reportLines.push('| Repository | Status | Reason |');
                reportLines.push('|------------|--------|---------|');
                
                for (const result of alreadyCentralized) {
                  reportLines.push(`| ${result.repository} | Skipped | Already has centralized workflows |`);
                }
                reportLines.push('');
              }
            }
            
            // Add attention section if there are items requiring attention
            const attentionItems = results.filter(r => r.requires_attention);
            if (attentionItems.length > 0) {
              reportLines.push('## Items Requiring Attention');
              reportLines.push('');
              for (const item of attentionItems) {
                reportLines.push(`- **${item.repository}**: ${item.details}`);
              }
              reportLines.push('');
            }
            
            reportLines.push('---');
            reportLines.push('*Generated by CAMARA project-admin bulk workflow*');
            
            const markdownReport = reportLines.join('\n');
            
            // Create CSV and JSON data
            let csvLines = ['Repository,Category,Result Type,Details,Operation Status,Action Taken,PR Number,PR URL,Commit SHA,Requires Attention'];
            if (operation === 'centralize-linting-workflows') {
              csvLines[0] += ',Had Prior Linting,Legacy Artifacts Count';
            }
            
            for (const result of results) {
              let csvLine = `"${result.repository}","${result.category}","${result.result_type}","${result.details}","${result.operation_status}","${result.action_taken}","${result.pr_number}","${result.pr_url}","${result.commit_sha}","${result.requires_attention}"`;
              if (operation === 'centralize-linting-workflows') {
                csvLine += `,"${result.had_prior_linting}","${result.legacy_artifacts_count}"`;
              }
              csvLines.push(csvLine);
            }
            const csvData = csvLines.join('\n');
            
            const jsonReport = {
              metadata: {
                timestamp: timestamp,
                operation: operation,
                commit_strategy: commitStrategy,
                dry_run: dryRun,
                total_repositories: totalRepos
              },
              summary: {
                result_types: resultTypeCounts,
                items_requiring_attention: attentionItems.length
              },
              results: results
            };
            
            if (operation === 'centralize-linting-workflows') {
              jsonReport.linting_statistics = lintingStats;
            }
            
            // Write files
            if (!fs.existsSync('results')) {
              fs.mkdirSync('results');
            }
            
            fs.writeFileSync('results/bulk-changes-report.md', markdownReport);
            fs.writeFileSync('results/bulk-changes-results.csv', csvData);
            fs.writeFileSync('results/bulk-changes-data.json', JSON.stringify(jsonReport, null, 2));
            
            console.log('‚úÖ Created result files');
            
            // Add summary to job summary
            core.summary.addRaw(markdownReport);
            await core.summary.write();
            
            console.log(`üìä Results summary completed - processed ${totalRepos} repositories`);
            
            // Log summary stats
            console.log('\n=== Summary Statistics ===');
            for (const [resultType, count] of Object.entries(resultTypeCounts)) {
              console.log(`${resultType}: ${count}`);
            }
            if (attentionItems.length > 0) {
              console.log(`\n‚ö†Ô∏è ${attentionItems.length} items require attention`);
            }

      - name: Upload results artifacts
        uses: actions/upload-artifact@v4
        with:
          name: bulk-changes-results-${{ github.run_number }}
          path: results/
          retention-days: 30

  summary:
    needs: [get-repositories, execute-changes, collect-results]
    if: always()
    runs-on: ubuntu-latest
    steps:
      - name: Final summary
        uses: actions/github-script@v7
        with:
          script: |
            const totalRepos = ${{ needs.get-repositories.outputs.total_count }};
            const operation = '${{ github.event.inputs.operation }}';
            const dryRun = ${{ fromJson(github.event.inputs.dry_run) }};
            const executionResult = '${{ needs.execute-changes.result }}';
            const collectionResult = '${{ needs.collect-results.result }}';
            
            let summary = `## Bulk Repository Changes Summary\n\n`;
            summary += `**Operation**: ${operation}\n`;
            summary += `**Mode**: ${dryRun ? 'DRY RUN' : 'LIVE'}\n`;
            summary += `**Total Repositories**: ${totalRepos}\n`;
            summary += `**Execution Status**: ${executionResult}\n`;
            summary += `**Results Collection**: ${collectionResult}\n\n`;
            
            if (totalRepos === 0) {
              summary += `‚ö†Ô∏è No repositories matched the selection criteria.\n`;
            } else {
              summary += `üìä **Detailed results available in downloadable artifacts**\n\n`;
              
              if (dryRun) {
                summary += `üß™ **This was a dry run** - no actual changes were made.\n`;
              } else {
                summary += `‚úÖ **Live execution completed**.\n`;
              }
            }
            
            core.summary.addRaw(summary);
            await core.summary.write();
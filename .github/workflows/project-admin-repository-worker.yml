# =========================================================================================
# CAMARA Project - Repository Worker (Reusable Workflow)
#
# This reusable workflow executes administrative operations on individual CAMARA repositories.
# It is called by both single repository test and bulk repository change workflows.
#
# CHANGELOG:
# - 2025-07-26: Initial version as is for r1.1 release of camaraproject/project-administration
# - 2025-07-28: Removed disable-wiki, add-changelog-codeowners, update-api-readiness-checklist; Added centralize-linting-workflows
#
# USAGE:
# - Called via workflow_call from other workflows
# - Supports multiple operations: add-changelog-file, update-swagger-links, centralize-linting-workflows, etc.
# - Handles both API-based and file-based operations with git/PR support
#
# DOCUMENTATION:
# see https://github.com/camaraproject/project-administration/blob/main/documentation/project-admin-bulk-repository-adminstration.md
# =========================================================================================

name: Repository Worker

on:
  workflow_call:
    inputs:
      repository_name:
        required: true
        type: string
      repository_full_name:
        required: true
        type: string
      default_branch:
        required: true
        type: string
      operation:
        required: true
        type: string
      dry_run:
        required: true
        type: boolean
      commit_strategy:
        required: false
        type: string
        default: 'pull-request'
    secrets:
      CAMARA_BULK_CHANGE_TOKEN:
        required: true

jobs:
  execute-operation:
    runs-on: ubuntu-latest
    permissions:
      contents: write       # For reading/writing repository files
      pull-requests: write  # For creating pull requests
    steps:
      - name: Checkout target repository
        uses: actions/checkout@v4
        with:
          repository: ${{ inputs.repository_full_name }}
          token: ${{ secrets.CAMARA_BULK_CHANGE_TOKEN || secrets.GITHUB_TOKEN }}
          ref: ${{ inputs.default_branch }}

      - name: Verify Token and Repository Access
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.CAMARA_BULK_CHANGE_TOKEN }}
          script: |
            const [owner, repo] = '${{ inputs.repository_full_name }}'.split('/');
            const operation = '${{ inputs.operation }}';
            
            try {
              // Test authentication and basic repository access
              const [userResponse, repoResponse] = await Promise.all([
                github.rest.users.getAuthenticated(),
                github.rest.repos.get({ owner, repo })
              ]);
              
              console.log(`‚úÖ Authenticated as: ${userResponse.data.login} (${userResponse.data.type})`);
              console.log(`üìù Commit identity: ${userResponse.data.name || userResponse.data.login} <${userResponse.data.email || `${userResponse.data.login}@users.noreply.github.com`}>`);
              console.log(`‚úÖ Repository access confirmed: ${repoResponse.data.full_name}`);
              
              // For file-based operations, verify write access
              if (['add-changelog-file', 'update-swagger-links', 'centralize-linting-workflows'].includes(operation)) {
                console.log('‚úÖ File-based operation - write permissions will be tested during git operations');
              }
              
              // For release-based operations, verify release write access
              if (operation === 'update-swagger-links-releases') {
                console.log('‚úÖ Release-based operation - release write permissions will be tested during API operations');
              }
              
            } catch (error) {
              const errorMsg = error.status === 401 ? 
                'Authentication failed - check CAMARA_BULK_CHANGE_TOKEN secret' :
                error.status === 403 ?
                'Access denied - check token permissions and organization access' :
                error.status === 404 ?
                'Repository not found or inaccessible' :
                `Unexpected error: ${error.message}`;
              
              core.setFailed(`‚ùå Access verification failed: ${errorMsg}`);
              throw error;
            }

      - name: Execute Operation - Update Swagger Links in Releases
        if: inputs.operation == 'update-swagger-links-releases'
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.CAMARA_BULK_CHANGE_TOKEN }}
          script: |
            const [owner, repo] = '${{ inputs.repository_full_name }}'.split('/');
            
            try {
              console.log('üîç Fetching repository releases...');
              
              // Get all releases (including drafts)
              let allReleases = [];
              let page = 1;
              
              while (true) {
                const response = await github.rest.repos.listReleases({
                  owner: owner,
                  repo: repo,
                  per_page: 100,
                  page: page
                });
                
                if (response.data.length === 0) break;
                allReleases = allReleases.concat(response.data);
                page++;
              }
              
              console.log(`üì¶ Found ${allReleases.length} release(s) to check`);
              
              if (allReleases.length === 0) {
                console.log('‚ÑπÔ∏è No releases found in repository');
                core.exportVariable('operation_status', 'no-releases');
                core.exportVariable('result_type', 'no-change');
                core.exportVariable('details', 'No releases found in repository');
                core.exportVariable('action_taken', 'none');
                return;
              }
              
              // Check releases for swagger editor links
              let releasesToUpdate = [];
              let totalLinksFound = 0;
              
              for (const release of allReleases) {
                if (!release.body) continue;
                
                const editorCount = (release.body.match(/https:\/\/editor\.swagger\.io\//g) || []).length;
                const editorNextCount = (release.body.match(/https:\/\/editor-next\.swagger\.io\//g) || []).length;
                const totalCount = editorCount + editorNextCount;
                
                if (totalCount > 0) {
                  releasesToUpdate.push({
                    release: release,
                    editorCount: editorCount,
                    editorNextCount: editorNextCount,
                    totalCount: totalCount
                  });
                  totalLinksFound += totalCount;
                  console.log(`üìù Release "${release.tag_name}" has ${totalCount} swagger editor link(s)`);
                }
              }
              
              if (releasesToUpdate.length === 0) {
                console.log('‚úÖ No swagger editor links found in any releases');
                core.exportVariable('operation_status', 'no-change');
                core.exportVariable('result_type', 'no-change');
                core.exportVariable('details', `No swagger editor links found in ${allReleases.length} release(s)`);
                core.exportVariable('action_taken', 'none');
                return;
              }
              
              if (${{ inputs.dry_run }}) {
                console.log(`üß™ DRY RUN: Would update ${totalLinksFound} swagger editor link(s) in ${releasesToUpdate.length} release(s)`);
                for (const item of releasesToUpdate) {
                  console.log(`üß™   - Release "${item.release.tag_name}": ${item.totalCount} link(s)`);
                }
                core.exportVariable('operation_status', 'would-update-releases');
                core.exportVariable('result_type', 'would-action');
                core.exportVariable('details', `Dry run: Would update ${totalLinksFound} swagger editor link(s) in ${releasesToUpdate.length} release(s)`);
                core.exportVariable('action_taken', 'dry-run');
                return;
              }
              
              // Update releases
              console.log(`üîÑ Updating ${releasesToUpdate.length} release(s)...`);
              let updatedReleases = [];
              let updatedLinksCount = 0;
              
              for (const item of releasesToUpdate) {
                try {
                  let updatedBody = item.release.body;
                  
                  // Replace editor.swagger.io links (simple host replacement)
                  if (item.editorCount > 0) {
                    updatedBody = updatedBody.replace(
                      /https:\/\/editor\.swagger\.io\//g,
                      'https://camaraproject.github.io/swagger-ui/'
                    );
                  }
                  
                  // Replace editor-next.swagger.io links (simple host replacement)
                  if (item.editorNextCount > 0) {
                    updatedBody = updatedBody.replace(
                      /https:\/\/editor-next\.swagger\.io\//g,
                      'https://camaraproject.github.io/swagger-ui/'
                    );
                  }
                  
                  // Update the release
                  await github.rest.repos.updateRelease({
                    owner: owner,
                    repo: repo,
                    release_id: item.release.id,
                    body: updatedBody
                  });
                  
                  console.log(`‚úÖ Updated release "${item.release.tag_name}" (${item.totalCount} link(s))`);
                  updatedReleases.push(item.release.tag_name);
                  updatedLinksCount += item.totalCount;
                  
                } catch (updateError) {
                  console.log(`‚ùå Failed to update release "${item.release.tag_name}": ${updateError.message}`);
                  throw updateError;
                }
              }
              
              console.log(`‚úÖ Successfully updated ${updatedLinksCount} swagger editor link(s) in ${updatedReleases.length} release(s)`);
              core.exportVariable('operation_status', 'releases-updated');
              core.exportVariable('result_type', 'success');
              core.exportVariable('details', `Updated ${updatedLinksCount} swagger editor link(s) in ${updatedReleases.length} release(s): ${updatedReleases.join(', ')}`);
              core.exportVariable('action_taken', 'release-updates');
              
            } catch (error) {
              if (error.status === 403) {
                core.setFailed(`‚ùå Permission denied: Insufficient permissions to update releases in ${owner}/${repo}`);
                core.exportVariable('operation_status', 'permission-denied');
                core.exportVariable('result_type', 'error');
                core.exportVariable('details', 'Permission denied: Insufficient permissions to update releases');
                core.exportVariable('action_taken', 'failed');
              } else if (error.status === 404) {
                core.setFailed(`‚ùå Repository not found: ${owner}/${repo}`);
                core.exportVariable('operation_status', 'repo-not-found');
                core.exportVariable('result_type', 'error');
                core.exportVariable('details', 'Repository not found');
                core.exportVariable('action_taken', 'failed');
              } else {
                core.setFailed(`‚ùå Failed to update releases: ${error.message} (HTTP ${error.status})`);
                core.exportVariable('operation_status', 'api-error');
                core.exportVariable('result_type', 'error');
                core.exportVariable('details', `Failed to update releases: ${error.message}`);
                core.exportVariable('action_taken', 'failed');
              }
              throw error;
            }

      - name: Execute Operation - Add Changelog File
        if: inputs.operation == 'add-changelog-file'
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.CAMARA_BULK_CHANGE_TOKEN }}
          script: |
            const [owner, repo] = '${{ inputs.repository_full_name }}'.split('/');
            const fs = require('fs');
            
            try {
              console.log('üîç Checking for existing CHANGELOG file...');
              
              // Set operation type flag
              core.exportVariable('needs_git_workflow', 'true');
              
              // Check for existing CHANGELOG files (both variants)
              let hasChangelog = false;
              let changelogVariant = '';
              
              if (fs.existsSync('CHANGELOG.md')) {
                hasChangelog = true;
                changelogVariant = 'CHANGELOG.md';
                console.log('‚úÖ Found CHANGELOG.md');
              } else if (fs.existsSync('CHANGELOG.MD')) {
                hasChangelog = true;
                changelogVariant = 'CHANGELOG.MD';
                console.log('‚úÖ Found CHANGELOG.MD');
              } else {
                console.log('‚ÑπÔ∏è No CHANGELOG file found');
              }
              
              console.log('üîç Checking for existing releases...');
              
              // Check for releases using GitHub API
              let hasReleases = false;
              try {
                const releasesResponse = await github.rest.repos.listReleases({
                  owner: owner,
                  repo: repo,
                  per_page: 1
                });
                hasReleases = releasesResponse.data.length > 0;
                
                if (hasReleases) {
                  console.log(`‚úÖ Repository has ${releasesResponse.data.length > 0 ? 'releases' : 'no releases'}`);
                } else {
                  console.log('‚ÑπÔ∏è Repository has no releases');
                }
              } catch (releasesError) {
                console.log(`‚ÑπÔ∏è Could not check releases (${releasesError.status}), assuming no releases`);
                hasReleases = false;
              }
              
              // Decision logic
              if (hasChangelog && hasReleases) {
                console.log('‚úÖ Repository already has both CHANGELOG and releases');
                core.exportVariable('operation_status', 'no-change');
                core.exportVariable('result_type', 'no-change');
                core.exportVariable('details', `Repository already has ${changelogVariant} file and releases`);
                core.exportVariable('action_taken', 'none');
                core.exportVariable('has_changes', 'false');
                
              } else if (!hasChangelog && !hasReleases) {
                console.log('üì• Downloading template CHANGELOG.md...');
                
                try {
                  // Download template CHANGELOG.md from Template_API_Repository
                  const templateResponse = await github.rest.repos.getContent({
                    owner: 'camaraproject',
                    repo: 'Template_API_Repository',
                    path: 'CHANGELOG.md'
                  });
                  
                  // Decode base64 content
                  const content = Buffer.from(templateResponse.data.content, 'base64').toString('utf8');
                  
                  // Write to file
                  fs.writeFileSync('CHANGELOG.md', content);
                  
                  console.log('‚úÖ Successfully downloaded and added template CHANGELOG.md');
                  core.exportVariable('operation_status', 'files-modified');
                  core.exportVariable('result_type', 'success');
                  core.exportVariable('details', 'Added template CHANGELOG.md file from Template_API_Repository');
                  core.exportVariable('action_taken', 'file-addition');
                  core.exportVariable('has_changes', 'true');
                  core.exportVariable('commit_message', 'admin: add template CHANGELOG.md file');
                  core.exportVariable('pr_title', 'admin: add template CHANGELOG.md file');
                  
                  const prBody = `## CAMARA Project Admin Update

            This pull request adds the standard CHANGELOG.md file template to this repository.

            **Changes:**
            - Added \`CHANGELOG.md\` using the template from Template_API_Repository
            - This establishes the standard changelog format for tracking release history

            **Why this change:**
            - Repository had no CHANGELOG file and no releases yet
            - Adding the template now ensures proper release documentation from the start
            - Follows CAMARA project standards for repository structure

            The CHANGELOG.md file should be updated with each release to document changes, improvements, and fixes.`;
                  
                  core.exportVariable('pr_body', prBody);
                  
                } catch (downloadError) {
                  console.log(`‚ùå Failed to download template CHANGELOG.md: ${downloadError.message}`);
                  core.exportVariable('operation_status', 'download-failed');
                  core.exportVariable('result_type', 'error');
                  core.exportVariable('details', `Failed to download template CHANGELOG.md: ${downloadError.message}`);
                  core.exportVariable('action_taken', 'failed');
                  core.exportVariable('has_changes', 'false');
                }
                
              } else if (hasChangelog && !hasReleases) {
                console.log('‚ö†Ô∏è Repository has CHANGELOG but no releases - manual review needed');
                core.exportVariable('operation_status', 'changelog-without-releases');
                core.exportVariable('result_type', 'warning');
                core.exportVariable('details', `Repository has ${changelogVariant} file but no releases - manual review recommended`);
                core.exportVariable('action_taken', 'skipped');
                core.exportVariable('has_changes', 'false');
                
              } else if (!hasChangelog && hasReleases) {
                console.log('‚ö†Ô∏è Repository has releases but no CHANGELOG - manual review needed');
                core.exportVariable('operation_status', 'releases-without-changelog');
                core.exportVariable('result_type', 'warning');
                core.exportVariable('details', 'Repository has releases but no CHANGELOG file - manual review recommended');
                core.exportVariable('action_taken', 'skipped');
                core.exportVariable('has_changes', 'false');
              }
              
            } catch (error) {
              console.log(`‚ùå Operation failed: ${error.message}`);
              core.exportVariable('operation_status', 'unexpected-error');
              core.exportVariable('result_type', 'error');
              core.exportVariable('details', `Operation failed: ${error.message}`);
              core.exportVariable('action_taken', 'failed');
              core.exportVariable('has_changes', 'false');
            }

      - name: Execute Operation - Update Swagger Links
        if: inputs.operation == 'update-swagger-links'
        run: |
          echo "üîç Searching for swagger editor links to update..."
          
          # Set operation type flag
          echo "needs_git_workflow=true" >> $GITHUB_ENV
          
          # Target files to check
          TARGET_FILES=("README.md" "README.MD" "CHANGELOG.md" "CHANGELOG.MD")
          
          MODIFIED_FILES=0
          UPDATED_FILES=""
          TOTAL_REPLACEMENTS=0
          
          for file in "${TARGET_FILES[@]}"; do
            if [ -f "$file" ]; then
              echo "üîç Checking $file..."
              
              # Count existing swagger editor links (simple host matching)
              EDITOR_COUNT=$(grep -c "https://editor\.swagger\.io/" "$file" 2>/dev/null || echo "0")
              EDITOR_NEXT_COUNT=$(grep -c "https://editor-next\.swagger\.io/" "$file" 2>/dev/null || echo "0")
              
              # Ensure we have valid numbers for arithmetic
              if ! [[ "$EDITOR_COUNT" =~ ^[0-9]+$ ]]; then
                EDITOR_COUNT=0
              fi
              if ! [[ "$EDITOR_NEXT_COUNT" =~ ^[0-9]+$ ]]; then
                EDITOR_NEXT_COUNT=0
              fi
              
              TOTAL_COUNT=$((EDITOR_COUNT + EDITOR_NEXT_COUNT))
              
              if [ $TOTAL_COUNT -gt 0 ]; then
                echo "üìù Found $TOTAL_COUNT swagger editor link(s) in $file"
                
                # Replace editor.swagger.io links (simple host replacement)
                if [ $EDITOR_COUNT -gt 0 ]; then
                  sed -i 's|https://editor\.swagger\.io/|https://camaraproject.github.io/swagger-ui/|g' "$file"
                  echo "   ‚úÖ Replaced $EDITOR_COUNT editor.swagger.io link(s)"
                fi
                
                # Replace editor-next.swagger.io links (simple host replacement)
                if [ $EDITOR_NEXT_COUNT -gt 0 ]; then
                  sed -i 's|https://editor-next\.swagger\.io/|https://camaraproject.github.io/swagger-ui/|g' "$file"
                  echo "   ‚úÖ Replaced $EDITOR_NEXT_COUNT editor-next.swagger.io link(s)"
                fi
                
                MODIFIED_FILES=$((MODIFIED_FILES + 1))
                UPDATED_FILES="$UPDATED_FILES $file"
                TOTAL_REPLACEMENTS=$((TOTAL_REPLACEMENTS + TOTAL_COUNT))
              else
                echo "   ‚ÑπÔ∏è No swagger editor links found in $file"
              fi
            else
              echo "   ‚ÑπÔ∏è File $file does not exist"
            fi
          done
          
          if [ $MODIFIED_FILES -eq 0 ]; then
            echo "‚úÖ No swagger editor links found that need updating"
            echo "operation_status=no-change" >> $GITHUB_ENV
            echo "result_type=no-change" >> $GITHUB_ENV
            echo "details=No swagger editor links found in README or CHANGELOG files" >> $GITHUB_ENV
            echo "action_taken=none" >> $GITHUB_ENV
            echo "has_changes=false" >> $GITHUB_ENV
          else
            echo "‚úÖ Updated $TOTAL_REPLACEMENTS swagger editor link(s) in $MODIFIED_FILES file(s):$UPDATED_FILES"
            echo "operation_status=files-modified" >> $GITHUB_ENV
            echo "result_type=success" >> $GITHUB_ENV
            echo "details=Updated $TOTAL_REPLACEMENTS swagger editor link(s) in $MODIFIED_FILES file(s)" >> $GITHUB_ENV
            echo "action_taken=file-modification" >> $GITHUB_ENV
            echo "has_changes=true" >> $GITHUB_ENV
            echo "commit_message=admin: migrate swagger editor links to CAMARA swagger-ui" >> $GITHUB_ENV
            echo "pr_title=admin: migrate swagger editor links to CAMARA swagger-ui" >> $GITHUB_ENV
            
            # Create PR body with proper variable substitution
            cat << EOF >> $GITHUB_ENV
          pr_body<<PRBODY
          ## CAMARA Project Admin Update
          
          This pull request migrates swagger editor links to use the CAMARA project's dedicated swagger-ui instance for better reliability (original links to swagger.io were broken).
          
          **Changes:**
          - Replaced \`https://editor.swagger.io/\` with \`https://camaraproject.github.io/swagger-ui/\`
          - Replaced \`https://editor-next.swagger.io/\` with \`https://camaraproject.github.io/swagger-ui/\`
          - All API specification URLs remain unchanged - only the swagger editor host is updated
          
          **Benefits:**
          - Consistent CAMARA experience
          - Centralized swagger-ui configuration
          - Maintained compatibility with existing specification URLs
          
          **Files modified:** $UPDATED_FILES
          **Links updated:** $TOTAL_REPLACEMENTS
          PRBODY
          EOF
          fi

      - name: Execute Operation - Centralize Linting Workflows
        if: inputs.operation == 'centralize-linting-workflows'
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.CAMARA_BULK_CHANGE_TOKEN }}
          script: |
            const [owner, repo] = '${{ inputs.repository_full_name }}'.split('/');
            const fs = require('fs');
            const path = require('path');
            
            try {
              console.log('üîç Analyzing current linting configuration...');
              
              // Set operation type flag
              core.exportVariable('needs_git_workflow', 'true');
              
              // Define files to check/remove
              const lintingArtifacts = {
                workflows: [
                  '.github/workflows/megalinter.yml',
                  '.github/workflows/spectral_oas_lint.yml'
                ],
                configs: [
                  '.spectral.yml',
                  '.yamllint.yaml',
                  '.gherkin-lintrc'
                ],
                directory: 'lint_function'
              };
              
              // Define new workflows to add
              const newWorkflows = [
                'spectral-oas-caller.yml',
                'pr_validation_caller.yml'
              ];
              
              // Check if already has centralized workflows
              let hasCentralizedWorkflows = true;
              for (const workflow of newWorkflows) {
                if (!fs.existsSync(path.join('.github', 'workflows', workflow))) {
                  hasCentralizedWorkflows = false;
                  break;
                }
              }
              
              if (hasCentralizedWorkflows) {
                console.log('‚úÖ Repository already has centralized workflows');
                core.exportVariable('operation_status', 'already-centralized');
                core.exportVariable('result_type', 'no-change');
                core.exportVariable('details', 'Repository already uses centralized linting workflows');
                core.exportVariable('action_taken', 'none');
                core.exportVariable('has_changes', 'false');
                return;
              }
              
              // Check for existing linting artifacts
              const foundArtifacts = [];
              let hasLegacyLinting = false;
              
              // Check workflow files
              for (const workflow of lintingArtifacts.workflows) {
                if (fs.existsSync(workflow)) {
                  foundArtifacts.push(workflow);
                  hasLegacyLinting = true;
                  console.log(`üìã Found legacy workflow: ${workflow}`);
                }
              }
              
              // Check config files
              for (const config of lintingArtifacts.configs) {
                if (fs.existsSync(config)) {
                  foundArtifacts.push(config);
                  hasLegacyLinting = true;
                  console.log(`üìã Found legacy config: ${config}`);
                }
              }
              
              // Check lint_function directory
              if (fs.existsSync(lintingArtifacts.directory)) {
                foundArtifacts.push(lintingArtifacts.directory);
                hasLegacyLinting = true;
                console.log(`üìã Found legacy directory: ${lintingArtifacts.directory}/`);
              }
              
              console.log(`üîç Legacy linting artifacts found: ${foundArtifacts.length}`);
              
              // Dry run mode - just report what would be done
              if (${{ inputs.dry_run }}) {
                const action = hasLegacyLinting ? 'migrate' : 'add';
                const details = hasLegacyLinting 
                  ? `Would migrate from local linting (remove ${foundArtifacts.length} artifacts, add 2 workflows)`
                  : 'Would add centralized linting workflows (no prior linting)';
                
                console.log(`üß™ DRY RUN: ${details}`);
                core.exportVariable('operation_status', `would-${action}`);
                core.exportVariable('result_type', 'would-action');
                core.exportVariable('details', `Dry run: ${details}`);
                core.exportVariable('action_taken', 'dry-run');
                core.exportVariable('has_changes', 'false');
                
                // Export statistics for reporting
                core.exportVariable('legacy_artifacts_count', foundArtifacts.length);
                core.exportVariable('legacy_artifacts', JSON.stringify(foundArtifacts));
                core.exportVariable('had_prior_linting', hasLegacyLinting);
                return;
              }
              
              // Download new workflows from tooling repository
              console.log('üì• Downloading centralized workflows from tooling repository...');
              
              const workflowsDir = '.github/workflows';
              if (!fs.existsSync(workflowsDir)) {
                fs.mkdirSync(workflowsDir, { recursive: true });
                console.log('üìÅ Created .github/workflows directory');
              }
              
              const downloadedWorkflows = [];
              for (const workflow of newWorkflows) {
                try {
                  console.log(`  üì• Downloading ${workflow}...`);
                  const response = await github.rest.repos.getContent({
                    owner: 'camaraproject',
                    repo: 'tooling',
                    path: `linting/workflows/${workflow}`
                  });
                  
                  const content = Buffer.from(response.data.content, 'base64').toString('utf8');
                  fs.writeFileSync(path.join(workflowsDir, workflow), content);
                  downloadedWorkflows.push(workflow);
                  console.log(`  ‚úÖ Downloaded ${workflow}`);
                } catch (downloadError) {
                  console.log(`  ‚ùå Failed to download ${workflow}: ${downloadError.message}`);
                  throw new Error(`Failed to download workflow ${workflow}: ${downloadError.message}`);
                }
              }
              
              // Remove legacy artifacts
              const removedArtifacts = [];
              if (hasLegacyLinting) {
                console.log('üßπ Removing legacy linting artifacts...');
                
                for (const artifact of foundArtifacts) {
                  try {
                    if (artifact === lintingArtifacts.directory) {
                      // Remove directory recursively
                      fs.rmSync(artifact, { recursive: true, force: true });
                      console.log(`  ‚úÖ Removed directory: ${artifact}/`);
                    } else {
                      // Remove file
                      fs.unlinkSync(artifact);
                      console.log(`  ‚úÖ Removed file: ${artifact}`);
                    }
                    removedArtifacts.push(artifact);
                  } catch (removeError) {
                    console.log(`  ‚ö†Ô∏è Could not remove ${artifact}: ${removeError.message}`);
                  }
                }
              }
              
              // Prepare commit message and PR body
              const action = hasLegacyLinting ? 'migrate' : 'add';
              const commitMessage = 'admin: migrate to centralized linting workflows';
              const prTitle = 'admin: migrate to centralized linting workflows';
              
              // Common next steps text
              const nextSteps = `### üë• Next Steps for Codeowners

            1. **Review and merge this PR** to enable centralized linting
            2. **Test the workflows immediately** by running them manually:
               - Go to Actions tab ‚Üí "Caller for Spectral linting with CAMARA ruleset" ‚Üí Run workflow
               - This will help identify any existing linting issues before your next PR
            3. **Address any linting errors** found during manual run:
               - Spectral errors usually relate to OpenAPI specification compliance
               - The workflow will provide detailed feedback on what needs fixing
               - Repositories without prior linting often have multiple issues to resolve
            4. **Create a cleanup PR** if needed:
               - Fix all identified linting issues in a dedicated PR
               - This ensures future feature PRs aren't blocked by pre-existing problems
            5. **Future PRs** will automatically run these checks:
               - All PRs to main branch trigger validation
               - Linting feedback appears directly in the PR
            6. **Monitor initial PRs** after merge to ensure smooth operation
               - First few PRs may reveal previously undetected issues
               - The Release Management team can assist with any questions

            üí° **Pro tip**: Running the Spectral workflow manually NOW is highly recommended. This allows you to fix issues proactively rather than discovering them when submitting your next feature PR!`;
              
              let prBody;
              if (hasLegacyLinting) {
                // Build list of removed artifacts for PR body
                const removedList = removedArtifacts.map(a => {
                  if (a.includes('megalinter.yml')) return '`megalinter.yml`';
                  if (a.includes('spectral_oas_lint.yml')) return '`spectral_oas_lint.yml`';
                  if (a === lintingArtifacts.directory) return 'Lint function scripts in `/lint_function/`';
                  if (a.includes('.spectral.yml')) return '`.spectral.yml`';
                  if (a.includes('.yamllint.yaml')) return '`.yamllint.yaml`';
                  if (a.includes('.gherkin-lintrc')) return '`.gherkin-lintrc`';
                  return `\`${a}\``;
                });
                
                prBody = `## CAMARA Project Admin Update - Linting Migration

            This pull request migrates this repository from local linting configuration to centralized linting workflows managed by the CAMARA project.

            ### üîÑ Migration Summary

            **Removed local linting artifacts:**
            ${removedList.map(item => `- ${item}`).join('\n')}

            **Added centralized workflows:**
            - \`spectral-oas-caller.yml\` - Spectral linting with CAMARA ruleset
            - \`pr_validation_caller.yml\` - Comprehensive PR validation

            ### ‚ú® Benefits of Centralized Linting

            1. **Always Up-to-Date**: Linting rules and workflows are automatically updated across all repositories
            2. **Consistent Standards**: Ensures uniform code quality checks across all CAMARA APIs
            3. **Reduced Maintenance**: No need to maintain linting configurations locally
            4. **Enhanced Features**: Access to latest tooling improvements without manual updates
            5. **Simplified Configuration**: Workflows reference the centralized tooling repository

            ### üìã What This Means for You

            - **No action required** for basic operation - workflows will run automatically
            - **All existing checks continue** with improved reliability
            - **Custom configurations** can be discussed with the Release Management team if needed

            ### üîß Technical Details

            The new workflows reference reusable workflows from:
            \`camaraproject/tooling/.github/workflows/\`

            This ensures all repositories benefit from:
            - Latest Spectral rules for OpenAPI validation
            - Consistent PR validation checks
            - Centralized rule management
            - Automated tooling updates

            ${nextSteps}`;
              } else {
                // No prior linting - prepend warning
                prBody = `## CAMARA Project Admin Update - Linting Setup

            This pull request adds centralized linting workflows to ensure code quality and API specification compliance.

            ### ‚úÖ Added Workflows

            - \`spectral-oas-caller.yml\` - Spectral linting with CAMARA ruleset for OpenAPI validation
            - \`pr_validation_caller.yml\` - Comprehensive PR validation checks

            ### ‚ú® Benefits

            1. **Automated Quality Checks**: Ensures API specifications meet CAMARA standards
            2. **PR Validation**: Automatic checks on all pull requests
            3. **Always Current**: Workflows reference centralized tooling for latest updates
            4. **Zero Maintenance**: No local configuration needed

            ### üìã What This Means for You

            - **Automated validation** on all pull requests to main branch
            - **Immediate feedback** on API specification compliance
            - **No local setup required** - everything is managed centrally

            ### üîß Technical Details

            The new workflows reference reusable workflows from:
            \`camaraproject/tooling/.github/workflows/\`

            This ensures all repositories benefit from:
            - Latest Spectral rules for OpenAPI validation
            - Consistent PR validation checks
            - Centralized rule management
            - Automated tooling updates

            ### üë• Next Steps for Codeowners

            ‚ö†Ô∏è **Important**: Since this repository had no prior linting, there may be existing issues to address.

            ${nextSteps.split('\n').slice(1).join('\n')}`; // Skip the first line (header) to avoid duplication
              }
              
              // Set result
              console.log(`‚úÖ Successfully ${action}d centralized linting workflows`);
              core.exportVariable('operation_status', `${action}-completed`);
              core.exportVariable('result_type', 'success');
              core.exportVariable('details', hasLegacyLinting 
                ? `Migrated from local linting (removed ${removedArtifacts.length} artifacts, added 2 workflows)`
                : 'Added centralized linting workflows (no prior linting)');
              core.exportVariable('action_taken', 'file-modification');
              core.exportVariable('has_changes', 'true');
              core.exportVariable('commit_message', commitMessage);
              core.exportVariable('pr_title', prTitle);
              core.exportVariable('pr_body', prBody);
              
              // Export statistics for reporting
              core.exportVariable('legacy_artifacts_count', removedArtifacts.length);
              core.exportVariable('legacy_artifacts', JSON.stringify(removedArtifacts));
              core.exportVariable('had_prior_linting', hasLegacyLinting);
              
            } catch (error) {
              console.log(`‚ùå Operation failed: ${error.message}`);
              core.exportVariable('operation_status', 'unexpected-error');
              core.exportVariable('result_type', 'error');
              core.exportVariable('details', `Operation failed: ${error.message}`);
              core.exportVariable('action_taken', 'failed');
              core.exportVariable('has_changes', 'false');
            }

      - name: Setup Git Configuration
        if: env.needs_git_workflow == 'true'
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.CAMARA_BULK_CHANGE_TOKEN }}
          script: |
            // Get authenticated user info for git configuration
            const authenticatedUser = await github.rest.users.getAuthenticated();
            const gitName = authenticatedUser.data.name || authenticatedUser.data.login;
            const gitEmail = authenticatedUser.data.email || `${authenticatedUser.data.login}@users.noreply.github.com`;
            
            console.log(`üîß Configuring git with: ${gitName} <${gitEmail}>`);
            
            // Export for use in subsequent steps
            core.exportVariable('GIT_AUTHOR_NAME', gitName);
            core.exportVariable('GIT_AUTHOR_EMAIL', gitEmail);
            core.exportVariable('GIT_COMMITTER_NAME', gitName);
            core.exportVariable('GIT_COMMITTER_EMAIL', gitEmail);
            
            // Also set for this step's shell commands
            core.exportVariable('COMMIT_AUTHOR_NAME', gitName);
            core.exportVariable('COMMIT_AUTHOR_EMAIL', gitEmail);

      - name: Configure Git
        if: env.needs_git_workflow == 'true'
        run: |
          git config user.name "${{ env.COMMIT_AUTHOR_NAME }}"
          git config user.email "${{ env.COMMIT_AUTHOR_EMAIL }}"
          echo "üìù Git configured for: $(git config user.name) <$(git config user.email)>"

      - name: Handle Dry Run
        if: env.has_changes == 'true' && inputs.dry_run == true && env.needs_git_workflow == 'true'
        run: |
          echo "üß™ DRY RUN: Would commit and create PR/commit with:"
          echo "  Commit message: ${{ env.commit_message }}"
          echo "  Strategy: ${{ inputs.commit_strategy }}"
          echo "  Author: $(git config user.name) <$(git config user.email)>"
          echo "  Files changed:"
          git status --porcelain
          
          # Update result for dry run
          echo "result_type=would-action" >> $GITHUB_ENV
          echo "action_taken=dry-run" >> $GITHUB_ENV
          echo "details=Dry run: Would apply changes using ${{ inputs.commit_strategy }} strategy" >> $GITHUB_ENV

      - name: Commit and Push Changes (Direct Strategy)
        if: env.has_changes == 'true' && inputs.dry_run == false && (inputs.commit_strategy == 'direct-with-warning' || inputs.commit_strategy == 'direct-with-pr-fallback') && env.needs_git_workflow == 'true'
        id: direct-commit
        continue-on-error: true
        run: |
          echo "üìù Attempting direct commit to ${{ inputs.default_branch }}..."
          
          git add .
          git commit -m "${{ env.commit_message }}

          Applied via project-admin workflow
          Repository: ${{ inputs.repository_name }}
          Operation: ${{ inputs.operation }}"
          
          if git push origin ${{ inputs.default_branch }}; then
            COMMIT_SHA=$(git rev-parse HEAD)
            echo "‚úÖ Direct commit successful"
            echo "commit_sha=$COMMIT_SHA" >> $GITHUB_ENV
            echo "action_taken=direct-commit" >> $GITHUB_ENV
            echo "details=${{ env.details }} (${COMMIT_SHA:0:7})" >> $GITHUB_ENV
            echo "direct_commit_success=true" >> $GITHUB_ENV
          else
            echo "‚ùå Direct commit failed"
            echo "direct_commit_success=false" >> $GITHUB_ENV
          fi

      - name: Handle Direct Commit Failure
        if: env.has_changes == 'true' && inputs.dry_run == false && steps.direct-commit.outcome == 'failure' && inputs.commit_strategy == 'direct-with-warning' && env.needs_git_workflow == 'true'
        run: |
          echo "‚ö†Ô∏è Direct commit blocked (likely branch protection) - operation skipped"
          echo "result_type=warning" >> $GITHUB_ENV
          echo "action_taken=skipped" >> $GITHUB_ENV
          echo "details=Direct commit blocked by branch protection" >> $GITHUB_ENV

      - name: Create Pull Request
        if: env.has_changes == 'true' && inputs.dry_run == false && (inputs.commit_strategy == 'pull-request' || (inputs.commit_strategy == 'direct-with-pr-fallback' && env.direct_commit_success != 'true')) && env.needs_git_workflow == 'true'
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.CAMARA_BULK_CHANGE_TOKEN }}
          script: |
            const [owner, repo] = '${{ inputs.repository_full_name }}'.split('/');
            const defaultBranch = '${{ inputs.default_branch }}';
            
            try {
              console.log('üîÑ Creating pull request...');
              
              // Get base commit SHA
              const branchResponse = await github.rest.repos.getBranch({
                owner: owner,
                repo: repo,
                branch: defaultBranch
              });
              const baseSha = branchResponse.data.commit.sha;
              
              // Create feature branch
              const timestamp = Date.now();
              const branchName = `camara-admin/${{ inputs.operation }}-${timestamp}`;
              
              await github.rest.git.createRef({
                owner: owner,
                repo: repo,
                ref: `refs/heads/${branchName}`,
                sha: baseSha
              });
              
              // Stage and commit changes on feature branch
              const { execSync } = require('child_process');
              
              execSync(`git checkout -b ${branchName}`, { stdio: 'inherit' });
              execSync('git add .', { stdio: 'inherit' });
              execSync(`git commit -m "${{ env.commit_message }}\n\nApplied via project-admin workflow\nRepository: ${{ inputs.repository_name }}\nOperation: ${{ inputs.operation }}"`, { stdio: 'inherit' });
              execSync(`git push origin ${branchName}`, { stdio: 'inherit' });
              
              // Get authenticated user for PR body personalization
              const authenticatedUser = await github.rest.users.getAuthenticated();
              
              const prBodyFooter = `\n\n---\nü§ñ **Generated via project-admin workflow**  
              Triggered by ${context.actor}, executed via ${authenticatedUser.data.login}
            
              **‚û°Ô∏è Next Steps:** This PR should be reviewed, approved, and merged by repository codeowners following standard review processes.
            
              ---
              *This is a manually triggered automated administrative update.*`;
            
              // Create pull request
              const prResponse = await github.rest.pulls.create({
                owner: owner,
                repo: repo,
                title: process.env.pr_title,
                head: branchName,
                base: defaultBranch,
                body: `${process.env.pr_body}${prBodyFooter}`
              });
              
              console.log(`‚úÖ Pull request created: ${prResponse.data.html_url}`);
              core.exportVariable('action_taken', 'pull-request');
              core.exportVariable('details', `${{ env.details }} (PR #${prResponse.data.number})`);
              core.exportVariable('pr_number', prResponse.data.number);
              core.exportVariable('pr_url', prResponse.data.html_url);
              
            } catch (error) {
              core.setFailed(`‚ùå Failed to create pull request: ${error.message}`);
              core.exportVariable('result_type', 'error');
              core.exportVariable('action_taken', 'failed');
              core.exportVariable('details', `Failed to create pull request: ${error.message}`);
            }

      - name: Determine result metadata
        if: always()
        run: |
          # Set default values if not already set by operation steps
          RESULT_TYPE="${{ env.result_type }}"
          DETAILS="${{ env.details }}"
          ACTION_TAKEN="${{ env.action_taken }}"
          OPERATION_STATUS="${{ env.operation_status }}"
          
          # Handle case where operation failed before setting result variables
          if [ -z "$RESULT_TYPE" ]; then
            RESULT_TYPE="unknown"
            DETAILS="Operation completed with unknown status"
            ACTION_TAKEN="unknown"
            OPERATION_STATUS="unknown"
          fi
          
          # Export final values
          echo "FINAL_RESULT_TYPE=$RESULT_TYPE" >> $GITHUB_ENV
          echo "FINAL_DETAILS=$DETAILS" >> $GITHUB_ENV
          echo "FINAL_ACTION_TAKEN=$ACTION_TAKEN" >> $GITHUB_ENV
          echo "FINAL_OPERATION_STATUS=$OPERATION_STATUS" >> $GITHUB_ENV
          
          echo "Result metadata determined:"
          echo "  Result Type: $RESULT_TYPE"
          echo "  Details: $DETAILS"
          echo "  Action Taken: $ACTION_TAKEN"
          echo "  Operation Status: $OPERATION_STATUS"

      - name: Create result file for collection
        if: always()
        run: |
          mkdir -p /tmp/results
          
          # Handle potentially empty environment variables
          PR_NUMBER="${{ env.pr_number }}"
          PR_URL="${{ env.pr_url }}"
          COMMIT_SHA="${{ env.commit_sha }}"
          
          # Additional data for centralize-linting operation
          LEGACY_ARTIFACTS_COUNT="${{ env.legacy_artifacts_count }}"
          LEGACY_ARTIFACTS="${{ env.legacy_artifacts }}"
          HAD_PRIOR_LINTING="${{ env.had_prior_linting }}"
          
          cat > /tmp/results/result-${{ inputs.repository_name }}.json << EOF
          {
            "repository": "${{ inputs.repository_name }}",
            "operation": "${{ inputs.operation }}",
            "result_type": "${{ env.FINAL_RESULT_TYPE }}",
            "details": "${{ env.FINAL_DETAILS }}",
            "operation_status": "${{ env.FINAL_OPERATION_STATUS }}",
            "action_taken": "${{ env.FINAL_ACTION_TAKEN }}",
            "dry_run": ${{ inputs.dry_run }},
            "commit_strategy": "${{ inputs.commit_strategy }}",
            "pr_number": "${PR_NUMBER:-}",
            "pr_url": "${PR_URL:-}",
            "commit_sha": "${COMMIT_SHA:-}",
            "legacy_artifacts_count": "${LEGACY_ARTIFACTS_COUNT:-0}",
            "legacy_artifacts": ${LEGACY_ARTIFACTS:-[]},
            "had_prior_linting": ${HAD_PRIOR_LINTING:-false},
            "timestamp": "$(date -u +%Y-%m-%dT%H:%M:%SZ)"
          }
          EOF

      - name: Upload result artifact
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: result-${{ inputs.repository_name }}
          path: /tmp/results/result-${{ inputs.repository_name }}.json
          retention-days: 1

      - name: Create summary
        run: |
          case "${{ env.FINAL_RESULT_TYPE }}" in
            "success") DISPLAY_EMOJI="‚úÖ" ;;
            "no-change") DISPLAY_EMOJI="üìä" ;;
            "warning") DISPLAY_EMOJI="‚ö†Ô∏è" ;;
            "would-action") DISPLAY_EMOJI="üß™" ;;
            "error") DISPLAY_EMOJI="‚ùå" ;;
            *) DISPLAY_EMOJI="‚ùì" ;;
          esac
          
          echo "## Repository: ${{ inputs.repository_name }}" >> $GITHUB_STEP_SUMMARY
          echo "**Operation**: ${{ inputs.operation }}" >> $GITHUB_STEP_SUMMARY
          echo "**Result**: $DISPLAY_EMOJI ${{ env.FINAL_RESULT_TYPE }}" >> $GITHUB_STEP_SUMMARY
          echo "**Details**: ${{ env.FINAL_DETAILS }}" >> $GITHUB_STEP_SUMMARY
          echo "**Action Taken**: ${{ env.FINAL_ACTION_TAKEN }}" >> $GITHUB_STEP_SUMMARY
          echo "**Dry Run**: ${{ inputs.dry_run }}" >> $GITHUB_STEP_SUMMARY
          echo "**Commit Strategy**: ${{ inputs.commit_strategy }}" >> $GITHUB_STEP_SUMMARY
          
          if [ -n "${{ env.pr_number }}" ]; then
            echo "**Pull Request**: #${{ env.pr_number }} - ${{ env.pr_url }}" >> $GITHUB_STEP_SUMMARY
          fi
          
          if [ -n "${{ env.commit_sha }}" ]; then
            echo "**Commit**: ${{ env.commit_sha }}" >> $GITHUB_STEP_SUMMARY
          fi
          
          if [[ "${{ env.FINAL_RESULT_TYPE }}" == "warning" || "${{ env.FINAL_RESULT_TYPE }}" == "error" ]]; then
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "‚ö†Ô∏è **This result requires attention**" >> $GITHUB_STEP_SUMMARY
          fi
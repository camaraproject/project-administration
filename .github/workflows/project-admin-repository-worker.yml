name: Repository Worker

on:
  workflow_call:
    inputs:
      repository_name:
        required: true
        type: string
      repository_full_name:
        required: true
        type: string
      default_branch:
        required: true
        type: string
      operation:
        required: true
        type: string
      dry_run:
        required: true
        type: boolean
      commit_strategy:
        required: false
        type: string
        default: 'pull-request'
    secrets:
      CAMARA_TOKEN:
        required: true

jobs:
  execute-operation:
    runs-on: ubuntu-latest
    permissions:
      contents: write       # For reading/writing repository files
      pull-requests: write  # For creating pull requests
    steps:
      - name: Checkout target repository
        uses: actions/checkout@v4
        with:
          repository: ${{ inputs.repository_full_name }}
          token: ${{ secrets.CAMARA_TOKEN || secrets.GITHUB_TOKEN }}
          ref: ${{ inputs.default_branch }}

      - name: Verify Token and Repository Access
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.CAMARA_TOKEN }}
          script: |
            const [owner, repo] = '${{ inputs.repository_full_name }}'.split('/');
            const operation = '${{ inputs.operation }}';
            
            try {
              // Test authentication and basic repository access
              const [userResponse, repoResponse] = await Promise.all([
                github.rest.users.getAuthenticated(),
                github.rest.repos.get({ owner, repo })
              ]);
              
              console.log(`‚úÖ Authenticated as: ${userResponse.data.login} (${userResponse.data.type})`);
              console.log(`üìù Commit identity: ${userResponse.data.name || userResponse.data.login} <${userResponse.data.email || `${userResponse.data.login}@users.noreply.github.com`}>`);
              console.log(`‚úÖ Repository access confirmed: ${repoResponse.data.full_name}`);
              
              // Operation-specific permission checks
              if (operation === 'disable-wiki') {
                try {
                  const collaboratorPermission = await github.rest.repos.getCollaboratorPermissionLevel({
                    owner,
                    repo,
                    username: userResponse.data.login
                  });
                  
                  if (collaboratorPermission.data.permission !== 'admin') {
                    core.warning(`‚ö†Ô∏è User may lack admin permissions for wiki operations on ${owner}/${repo}`);
                  } else {
                    console.log('‚úÖ Admin permissions confirmed for wiki operations');
                  }
                } catch (permissionError) {
                  core.warning(`‚ö†Ô∏è Could not verify admin permissions - proceeding with wiki operation`);
                }
              }
              
              // For file-based operations, verify write access
              if (['add-changelog-codeowners', 'add-changelog-file', 'update-swagger-links'].includes(operation)) {
                console.log('‚úÖ File-based operation - write permissions will be tested during git operations');
              }
              
              // For release-based operations, verify release write access
              if (operation === 'update-swagger-links-releases') {
                console.log('‚úÖ Release-based operation - release write permissions will be tested during API operations');
              }
              
            } catch (error) {
              const errorMsg = error.status === 401 ? 
                'Authentication failed - check CAMARA_TOKEN secret' :
                error.status === 403 ?
                'Access denied - check token permissions and organization access' :
                error.status === 404 ?
                'Repository not found or inaccessible' :
                `Unexpected error: ${error.message}`;
              
              core.setFailed(`‚ùå Access verification failed: ${errorMsg}`);
              throw error;
            }

      - name: Setup Git Configuration
        if: contains(fromJson('["add-changelog-codeowners", "add-changelog-file", "update-swagger-links"]'), inputs.operation)
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.CAMARA_TOKEN }}
          script: |
            // Get authenticated user info for git configuration
            const authenticatedUser = await github.rest.users.getAuthenticated();
            const gitName = authenticatedUser.data.name || authenticatedUser.data.login;
            const gitEmail = authenticatedUser.data.email || `${authenticatedUser.data.login}@users.noreply.github.com`;
            
            console.log(`üîß Configuring git with: ${gitName} <${gitEmail}>`);
            
            // Export for use in subsequent steps
            core.exportVariable('GIT_AUTHOR_NAME', gitName);
            core.exportVariable('GIT_AUTHOR_EMAIL', gitEmail);
            core.exportVariable('GIT_COMMITTER_NAME', gitName);
            core.exportVariable('GIT_COMMITTER_EMAIL', gitEmail);
            
            // Also set for this step's shell commands
            core.exportVariable('COMMIT_AUTHOR_NAME', gitName);
            core.exportVariable('COMMIT_AUTHOR_EMAIL', gitEmail);

      - name: Configure Git
        if: contains(fromJson('["add-changelog-codeowners", "add-changelog-file", "update-swagger-links"]'), inputs.operation)
        run: |
          git config user.name "${{ env.COMMIT_AUTHOR_NAME }}"
          git config user.email "${{ env.COMMIT_AUTHOR_EMAIL }}"
          echo "üìù Git configured for: $(git config user.name) <$(git config user.email)>"

      - name: Execute Operation - Disable Wiki
        if: inputs.operation == 'disable-wiki'
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.CAMARA_TOKEN }}
          script: |
            const [owner, repo] = '${{ inputs.repository_full_name }}'.split('/');
            
            try {
              // Check if wiki is enabled
              const repoInfo = await github.rest.repos.get({
                owner: owner,
                repo: repo
              });
              
              if (!repoInfo.data.has_wiki) {
                console.log('‚úÖ Wiki is already disabled');
                core.exportVariable('operation_status', 'no-change');
                core.exportVariable('result_type', 'no-change');
                core.exportVariable('details', 'Wiki already disabled');
                core.exportVariable('action_taken', 'none');
                return;
              }
              
              // Check if wiki has content
              let hasWikiContent = false;
              try {
                await github.request('GET /repos/{owner}/{repo}/wiki', {
                  owner: owner,
                  repo: repo
                });
                hasWikiContent = true;
              } catch (wikiError) {
                hasWikiContent = wikiError.status !== 404;
              }
              
              if (hasWikiContent) {
                console.log('‚ö†Ô∏è Wiki contains content - skipping disable for safety');
                core.exportVariable('operation_status', 'wiki-has-content');
                core.exportVariable('result_type', 'warning');
                core.exportVariable('details', 'Wiki has content - skipped for safety');
                core.exportVariable('action_taken', 'skipped');
                return;
              }
              
              if (${{ inputs.dry_run }}) {
                console.log('üß™ DRY RUN: Would disable wiki (currently enabled but empty)');
                core.exportVariable('operation_status', 'would-disable-wiki');
                core.exportVariable('result_type', 'would-action');
                core.exportVariable('details', 'Dry run: Would disable wiki');
                core.exportVariable('action_taken', 'dry-run');
                return;
              }
              
              // Disable wiki
              try {
                await github.rest.repos.update({
                  owner: owner,
                  repo: repo,
                  has_wiki: false
                });
                console.log('‚úÖ Wiki disabled successfully');
                core.exportVariable('operation_status', 'wiki-disabled');
                core.exportVariable('result_type', 'success');
                core.exportVariable('details', 'Wiki disabled successfully');
                core.exportVariable('action_taken', 'wiki-disabled');
              } catch (updateError) {
                if (updateError.status === 403) {
                  core.setFailed(`‚ùå Permission denied: Admin access required to disable wiki on ${owner}/${repo}`);
                  core.exportVariable('operation_status', 'permission-denied');
                  core.exportVariable('result_type', 'error');
                  core.exportVariable('details', 'Permission denied: Admin access required');
                  core.exportVariable('action_taken', 'failed');
                } else if (updateError.status === 404) {
                  core.setFailed(`‚ùå Repository not found: ${owner}/${repo}`);
                  core.exportVariable('operation_status', 'repo-not-found');
                  core.exportVariable('result_type', 'error');
                  core.exportVariable('details', 'Repository not found');
                  core.exportVariable('action_taken', 'failed');
                } else if (updateError.status === 422) {
                  core.setFailed(`‚ùå Cannot update repository settings - may be restricted by organization policies`);
                  core.exportVariable('operation_status', 'update-restricted');
                  core.exportVariable('result_type', 'error');
                  core.exportVariable('details', 'Cannot update repository settings - restricted by organization policies');
                  core.exportVariable('action_taken', 'failed');
                } else {
                  core.setFailed(`‚ùå Failed to disable wiki: ${updateError.message} (HTTP ${updateError.status})`);
                  core.exportVariable('operation_status', 'api-error');
                  core.exportVariable('result_type', 'error');
                  core.exportVariable('details', `Failed to disable wiki: ${updateError.message}`);
                  core.exportVariable('action_taken', 'failed');
                }
                throw updateError;
              }
              
            } catch (error) {
              if (!error.message.includes('Permission denied') && !error.message.includes('Failed to disable wiki')) {
                core.setFailed(`‚ùå Wiki operation failed: ${error.message}`);
                core.exportVariable('operation_status', 'unexpected-error');
                core.exportVariable('result_type', 'error');
                core.exportVariable('details', `Wiki operation failed: ${error.message}`);
                core.exportVariable('action_taken', 'failed');
              }
            }

      - name: Execute Operation - Update Swagger Links in Releases
        if: inputs.operation == 'update-swagger-links-releases'
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.CAMARA_TOKEN }}
          script: |
            const [owner, repo] = '${{ inputs.repository_full_name }}'.split('/');
            
            try {
              console.log('üîç Fetching repository releases...');
              
              // Get all releases (including drafts)
              let allReleases = [];
              let page = 1;
              
              while (true) {
                const response = await github.rest.repos.listReleases({
                  owner: owner,
                  repo: repo,
                  per_page: 100,
                  page: page
                });
                
                if (response.data.length === 0) break;
                allReleases = allReleases.concat(response.data);
                page++;
              }
              
              console.log(`üì¶ Found ${allReleases.length} release(s) to check`);
              
              if (allReleases.length === 0) {
                console.log('‚ÑπÔ∏è No releases found in repository');
                core.exportVariable('operation_status', 'no-releases');
                core.exportVariable('result_type', 'no-change');
                core.exportVariable('details', 'No releases found in repository');
                core.exportVariable('action_taken', 'none');
                return;
              }
              
              // Check releases for swagger editor links
              let releasesToUpdate = [];
              let totalLinksFound = 0;
              
              for (const release of allReleases) {
                if (!release.body) continue;
                
                const editorCount = (release.body.match(/https:\/\/editor\.swagger\.io\//g) || []).length;
                const editorNextCount = (release.body.match(/https:\/\/editor-next\.swagger\.io\//g) || []).length;
                const totalCount = editorCount + editorNextCount;
                
                if (totalCount > 0) {
                  releasesToUpdate.push({
                    release: release,
                    editorCount: editorCount,
                    editorNextCount: editorNextCount,
                    totalCount: totalCount
                  });
                  totalLinksFound += totalCount;
                  console.log(`üìù Release "${release.tag_name}" has ${totalCount} swagger editor link(s)`);
                }
              }
              
              if (releasesToUpdate.length === 0) {
                console.log('‚úÖ No swagger editor links found in any releases');
                core.exportVariable('operation_status', 'no-change');
                core.exportVariable('result_type', 'no-change');
                core.exportVariable('details', `No swagger editor links found in ${allReleases.length} release(s)`);
                core.exportVariable('action_taken', 'none');
                return;
              }
              
              if (${{ inputs.dry_run }}) {
                console.log(`üß™ DRY RUN: Would update ${totalLinksFound} swagger editor link(s) in ${releasesToUpdate.length} release(s)`);
                for (const item of releasesToUpdate) {
                  console.log(`üß™   - Release "${item.release.tag_name}": ${item.totalCount} link(s)`);
                }
                core.exportVariable('operation_status', 'would-update-releases');
                core.exportVariable('result_type', 'would-action');
                core.exportVariable('details', `Dry run: Would update ${totalLinksFound} swagger editor link(s) in ${releasesToUpdate.length} release(s)`);
                core.exportVariable('action_taken', 'dry-run');
                return;
              }
              
              // Update releases
              console.log(`üîÑ Updating ${releasesToUpdate.length} release(s)...`);
              let updatedReleases = [];
              let updatedLinksCount = 0;
              
              for (const item of releasesToUpdate) {
                try {
                  let updatedBody = item.release.body;
                  
                  // Replace editor.swagger.io links (simple host replacement)
                  if (item.editorCount > 0) {
                    updatedBody = updatedBody.replace(
                      /https:\/\/editor\.swagger\.io\//g,
                      'https://camaraproject.github.io/swagger-ui/'
                    );
                  }
                  
                  // Replace editor-next.swagger.io links (simple host replacement)
                  if (item.editorNextCount > 0) {
                    updatedBody = updatedBody.replace(
                      /https:\/\/editor-next\.swagger\.io\//g,
                      'https://camaraproject.github.io/swagger-ui/'
                    );
                  }
                  
                  // Update the release
                  await github.rest.repos.updateRelease({
                    owner: owner,
                    repo: repo,
                    release_id: item.release.id,
                    body: updatedBody
                  });
                  
                  console.log(`‚úÖ Updated release "${item.release.tag_name}" (${item.totalCount} link(s))`);
                  updatedReleases.push(item.release.tag_name);
                  updatedLinksCount += item.totalCount;
                  
                } catch (updateError) {
                  console.log(`‚ùå Failed to update release "${item.release.tag_name}": ${updateError.message}`);
                  throw updateError;
                }
              }
              
              console.log(`‚úÖ Successfully updated ${updatedLinksCount} swagger editor link(s) in ${updatedReleases.length} release(s)`);
              core.exportVariable('operation_status', 'releases-updated');
              core.exportVariable('result_type', 'success');
              core.exportVariable('details', `Updated ${updatedLinksCount} swagger editor link(s) in ${updatedReleases.length} release(s): ${updatedReleases.join(', ')}`);
              core.exportVariable('action_taken', 'release-updates');
              
            } catch (error) {
              if (error.status === 403) {
                core.setFailed(`‚ùå Permission denied: Insufficient permissions to update releases in ${owner}/${repo}`);
                core.exportVariable('operation_status', 'permission-denied');
                core.exportVariable('result_type', 'error');
                core.exportVariable('details', 'Permission denied: Insufficient permissions to update releases');
                core.exportVariable('action_taken', 'failed');
              } else if (error.status === 404) {
                core.setFailed(`‚ùå Repository not found: ${owner}/${repo}`);
                core.exportVariable('operation_status', 'repo-not-found');
                core.exportVariable('result_type', 'error');
                core.exportVariable('details', 'Repository not found');
                core.exportVariable('action_taken', 'failed');
              } else {
                core.setFailed(`‚ùå Failed to update releases: ${error.message} (HTTP ${error.status})`);
                core.exportVariable('operation_status', 'api-error');
                core.exportVariable('result_type', 'error');
                core.exportVariable('details', `Failed to update releases: ${error.message}`);
                core.exportVariable('action_taken', 'failed');
              }
              throw error;
            }

      - name: Execute Operation - Add Changelog CODEOWNERS
        if: inputs.operation == 'add-changelog-codeowners'
        run: |
          echo "üîç Checking for CODEOWNERS file..."
          
          if [ ! -f "CODEOWNERS" ]; then
            echo "‚ö†Ô∏è CODEOWNERS file not found"
            echo "operation_status=no-codeowners-file" >> $GITHUB_ENV
            echo "result_type=warning" >> $GITHUB_ENV
            echo "details=No CODEOWNERS file found" >> $GITHUB_ENV
            echo "action_taken=skipped" >> $GITHUB_ENV
            echo "has_changes=false" >> $GITHUB_ENV
            exit 0
          fi
          
          # Check if CHANGELOG rules already exist
          if grep -q "/CHANGELOG\.MD\|/CHANGELOG\.md" CODEOWNERS; then
            echo "‚úÖ CHANGELOG rule already exists"
            echo "operation_status=no-change" >> $GITHUB_ENV
            echo "result_type=no-change" >> $GITHUB_ENV
            echo "details=CHANGELOG rule already exists" >> $GITHUB_ENV
            echo "action_taken=none" >> $GITHUB_ENV
            echo "has_changes=false" >> $GITHUB_ENV
            exit 0
          fi
          
          # Add CHANGELOG rules
          echo "" >> CODEOWNERS
          echo "# The following lines ensure that the release-management_reviewers team will automatically added as reviewers" >> CODEOWNERS
          echo "# if a pull requests is changing the CHANGELOG file (aka \"release PR\") and that such PRs can only be merged with an approval from a team member." >> CODEOWNERS
          echo "/CHANGELOG.MD @camaraproject/release-management_reviewers" >> CODEOWNERS
          echo "/CHANGELOG.md @camaraproject/release-management_reviewers" >> CODEOWNERS
          
          echo "‚úÖ Added CHANGELOG rules to CODEOWNERS"
          echo "operation_status=files-modified" >> $GITHUB_ENV
          echo "result_type=success" >> $GITHUB_ENV
          echo "details=Added CHANGELOG files to CODEOWNERS" >> $GITHUB_ENV
          echo "action_taken=file-modification" >> $GITHUB_ENV
          echo "has_changes=true" >> $GITHUB_ENV
          echo "commit_message=chore: add CHANGELOG files to CODEOWNERS for release management" >> $GITHUB_ENV
          echo "pr_title=chore: add CHANGELOG files to CODEOWNERS for release management" >> $GITHUB_ENV
          echo "pr_body<<EOF" >> $GITHUB_ENV
          cat << 'PRBODY' >> $GITHUB_ENV
          ## CAMARA Project Admin Update
          
          This pull request adds CHANGELOG files to CODEOWNERS to ensure that:
          - The release-management_reviewers team is automatically added as reviewers for release PRs
          - Release PRs (those changing CHANGELOG files) require approval from the release management team
          
          **Changes:**
          - Added `/CHANGELOG.MD @camaraproject/release-management_reviewers` to CODEOWNERS
          - Added `/CHANGELOG.md @camaraproject/release-management_reviewers` to CODEOWNERS
          
          This covers both uppercase and lowercase variants of the changelog filename.
          PRBODY
          echo "EOF" >> $GITHUB_ENV

      - name: Execute Operation - Add Changelog File
        if: inputs.operation == 'add-changelog-file'
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.CAMARA_TOKEN }}
          script: |
            const [owner, repo] = '${{ inputs.repository_full_name }}'.split('/');
            const fs = require('fs');
            
            try {
              console.log('üîç Checking for existing CHANGELOG file...');
              
              // Check for existing CHANGELOG files (both variants)
              let hasChangelog = false;
              let changelogVariant = '';
              
              if (fs.existsSync('CHANGELOG.md')) {
                hasChangelog = true;
                changelogVariant = 'CHANGELOG.md';
                console.log('‚úÖ Found CHANGELOG.md');
              } else if (fs.existsSync('CHANGELOG.MD')) {
                hasChangelog = true;
                changelogVariant = 'CHANGELOG.MD';
                console.log('‚úÖ Found CHANGELOG.MD');
              } else {
                console.log('‚ÑπÔ∏è No CHANGELOG file found');
              }
              
              console.log('üîç Checking for existing releases...');
              
              // Check for releases using GitHub API
              let hasReleases = false;
              try {
                const releasesResponse = await github.rest.repos.listReleases({
                  owner: owner,
                  repo: repo,
                  per_page: 1
                });
                hasReleases = releasesResponse.data.length > 0;
                
                if (hasReleases) {
                  console.log(`‚úÖ Repository has ${releasesResponse.data.length > 0 ? 'releases' : 'no releases'}`);
                } else {
                  console.log('‚ÑπÔ∏è Repository has no releases');
                }
              } catch (releasesError) {
                console.log(`‚ÑπÔ∏è Could not check releases (${releasesError.status}), assuming no releases`);
                hasReleases = false;
              }
              
              // Decision logic
              if (hasChangelog && hasReleases) {
                console.log('‚úÖ Repository already has both CHANGELOG and releases');
                core.exportVariable('operation_status', 'no-change');
                core.exportVariable('result_type', 'no-change');
                core.exportVariable('details', `Repository already has ${changelogVariant} file and releases`);
                core.exportVariable('action_taken', 'none');
                core.exportVariable('has_changes', 'false');
                
              } else if (!hasChangelog && !hasReleases) {
                console.log('üì• Downloading template CHANGELOG.md...');
                
                try {
                  // Download template CHANGELOG.md from Template_API_Repository
                  const templateResponse = await github.rest.repos.getContent({
                    owner: 'camaraproject',
                    repo: 'Template_API_Repository',
                    path: 'CHANGELOG.md'
                  });
                  
                  // Decode base64 content
                  const content = Buffer.from(templateResponse.data.content, 'base64').toString('utf8');
                  
                  // Write to file
                  fs.writeFileSync('CHANGELOG.md', content);
                  
                  console.log('‚úÖ Successfully downloaded and added template CHANGELOG.md');
                  core.exportVariable('operation_status', 'files-modified');
                  core.exportVariable('result_type', 'success');
                  core.exportVariable('details', 'Added template CHANGELOG.md file from Template_API_Repository');
                  core.exportVariable('action_taken', 'file-addition');
                  core.exportVariable('has_changes', 'true');
                  core.exportVariable('commit_message', 'chore: add template CHANGELOG.md file');
                  core.exportVariable('pr_title', 'chore: add template CHANGELOG.md file');
                  
                  const prBody = `## CAMARA Project Admin Update

            This pull request adds the standard CHANGELOG.md file template to this repository.

            **Changes:**
            - Added \`CHANGELOG.md\` using the template from Template_API_Repository
            - This establishes the standard changelog format for tracking release history

            **Why this change:**
            - Repository had no CHANGELOG file and no releases yet
            - Adding the template now ensures proper release documentation from the start
            - Follows CAMARA project standards for repository structure

            The CHANGELOG.md file should be updated with each release to document changes, improvements, and fixes.`;
                  
                  core.exportVariable('pr_body', prBody);
                  
                } catch (downloadError) {
                  console.log(`‚ùå Failed to download template CHANGELOG.md: ${downloadError.message}`);
                  core.exportVariable('operation_status', 'download-failed');
                  core.exportVariable('result_type', 'error');
                  core.exportVariable('details', `Failed to download template CHANGELOG.md: ${downloadError.message}`);
                  core.exportVariable('action_taken', 'failed');
                  core.exportVariable('has_changes', 'false');
                }
                
              } else if (hasChangelog && !hasReleases) {
                console.log('‚ö†Ô∏è Repository has CHANGELOG but no releases - manual review needed');
                core.exportVariable('operation_status', 'changelog-without-releases');
                core.exportVariable('result_type', 'warning');
                core.exportVariable('details', `Repository has ${changelogVariant} file but no releases - manual review recommended`);
                core.exportVariable('action_taken', 'skipped');
                core.exportVariable('has_changes', 'false');
                
              } else if (!hasChangelog && hasReleases) {
                console.log('‚ö†Ô∏è Repository has releases but no CHANGELOG - manual review needed');
                core.exportVariable('operation_status', 'releases-without-changelog');
                core.exportVariable('result_type', 'warning');
                core.exportVariable('details', 'Repository has releases but no CHANGELOG file - manual review recommended');
                core.exportVariable('action_taken', 'skipped');
                core.exportVariable('has_changes', 'false');
              }
              
            } catch (error) {
              console.log(`‚ùå Operation failed: ${error.message}`);
              core.exportVariable('operation_status', 'unexpected-error');
              core.exportVariable('result_type', 'error');
              core.exportVariable('details', `Operation failed: ${error.message}`);
              core.exportVariable('action_taken', 'failed');
              core.exportVariable('has_changes', 'false');
            }

      - name: Execute Operation - Update Swagger Links
        if: inputs.operation == 'update-swagger-links'
        run: |
          echo "üîç Searching for swagger editor links to update..."
          
          # Target files to check
          TARGET_FILES=("README.md" "README.MD" "CHANGELOG.md" "CHANGELOG.MD")
          
          MODIFIED_FILES=0
          UPDATED_FILES=""
          TOTAL_REPLACEMENTS=0
          
          for file in "${TARGET_FILES[@]}"; do
            if [ -f "$file" ]; then
              echo "üîç Checking $file..."
              
              # Count existing swagger editor links (simple host matching)
              EDITOR_COUNT=$(grep -c "https://editor\.swagger\.io/" "$file" 2>/dev/null || echo "0")
              EDITOR_NEXT_COUNT=$(grep -c "https://editor-next\.swagger\.io/" "$file" 2>/dev/null || echo "0")
              
              # Ensure we have valid numbers for arithmetic
              if ! [[ "$EDITOR_COUNT" =~ ^[0-9]+$ ]]; then
                EDITOR_COUNT=0
              fi
              if ! [[ "$EDITOR_NEXT_COUNT" =~ ^[0-9]+$ ]]; then
                EDITOR_NEXT_COUNT=0
              fi
              
              TOTAL_COUNT=$((EDITOR_COUNT + EDITOR_NEXT_COUNT))
              
              if [ $TOTAL_COUNT -gt 0 ]; then
                echo "üìù Found $TOTAL_COUNT swagger editor link(s) in $file"
                
                # Replace editor.swagger.io links (simple host replacement)
                if [ $EDITOR_COUNT -gt 0 ]; then
                  sed -i 's|https://editor\.swagger\.io/|https://camaraproject.github.io/swagger-ui/|g' "$file"
                  echo "   ‚úÖ Replaced $EDITOR_COUNT editor.swagger.io link(s)"
                fi
                
                # Replace editor-next.swagger.io links (simple host replacement)
                if [ $EDITOR_NEXT_COUNT -gt 0 ]; then
                  sed -i 's|https://editor-next\.swagger\.io/|https://camaraproject.github.io/swagger-ui/|g' "$file"
                  echo "   ‚úÖ Replaced $EDITOR_NEXT_COUNT editor-next.swagger.io link(s)"
                fi
                
                MODIFIED_FILES=$((MODIFIED_FILES + 1))
                UPDATED_FILES="$UPDATED_FILES $file"
                TOTAL_REPLACEMENTS=$((TOTAL_REPLACEMENTS + TOTAL_COUNT))
              else
                echo "   ‚ÑπÔ∏è No swagger editor links found in $file"
              fi
            else
              echo "   ‚ÑπÔ∏è File $file does not exist"
            fi
          done
          
          if [ $MODIFIED_FILES -eq 0 ]; then
            echo "‚úÖ No swagger editor links found that need updating"
            echo "operation_status=no-change" >> $GITHUB_ENV
            echo "result_type=no-change" >> $GITHUB_ENV
            echo "details=No swagger editor links found in README or CHANGELOG files" >> $GITHUB_ENV
            echo "action_taken=none" >> $GITHUB_ENV
            echo "has_changes=false" >> $GITHUB_ENV
          else
            echo "‚úÖ Updated $TOTAL_REPLACEMENTS swagger editor link(s) in $MODIFIED_FILES file(s):$UPDATED_FILES"
            echo "operation_status=files-modified" >> $GITHUB_ENV
            echo "result_type=success" >> $GITHUB_ENV
            echo "details=Updated $TOTAL_REPLACEMENTS swagger editor link(s) in $MODIFIED_FILES file(s)" >> $GITHUB_ENV
            echo "action_taken=file-modification" >> $GITHUB_ENV
            echo "has_changes=true" >> $GITHUB_ENV
            echo "commit_message=chore: migrate swagger editor links to CAMARA swagger-ui" >> $GITHUB_ENV
            echo "pr_title=chore: migrate swagger editor links to CAMARA swagger-ui" >> $GITHUB_ENV
            echo "pr_body<<EOF" >> $GITHUB_ENV
            cat << 'PRBODY' >> $GITHUB_ENV
          ## CAMARA Project Admin Update
          
          This pull request migrates swagger editor links to use the CAMARA project's dedicated swagger-ui instance for better reliability (original links to swagger.io were broken).
          
          **Changes:**
          - Replaced \`https://editor.swagger.io/\` with \`https://camaraproject.github.io/swagger-ui/\`
          - Replaced \`https://editor-next.swagger.io/\` with \`https://camaraproject.github.io/swagger-ui/\`
          - All API specification URLs remain unchanged - only the swagger editor host is updated
          
          **Benefits:**
          - Consistent CAMARA experience
          - Centralized swagger-ui configuration
          - Maintained compatibility with existing specification URLs
          
          **Files modified:** $UPDATED_FILES
          **Links updated:** $TOTAL_REPLACEMENTS
          PRBODY
            echo "EOF" >> $GITHUB_ENV
          fi

      - name: Handle Dry Run
        if: env.has_changes == 'true' && inputs.dry_run == true && contains(fromJson('["add-changelog-codeowners", "add-changelog-file", "update-swagger-links"]'), inputs.operation)
        run: |
          echo "üß™ DRY RUN: Would commit and create PR/commit with:"
          echo "  Commit message: ${{ env.commit_message }}"
          echo "  Strategy: ${{ inputs.commit_strategy }}"
          echo "  Author: $(git config user.name) <$(git config user.email)>"
          echo "  Files changed:"
          git status --porcelain
          
          # Update result for dry run
          echo "result_type=would-action" >> $GITHUB_ENV
          echo "action_taken=dry-run" >> $GITHUB_ENV
          echo "details=Dry run: Would apply changes using ${{ inputs.commit_strategy }} strategy" >> $GITHUB_ENV

      - name: Commit and Push Changes (Direct Strategy)
        if: env.has_changes == 'true' && inputs.dry_run == false && (inputs.commit_strategy == 'direct-with-warning' || inputs.commit_strategy == 'direct-with-pr-fallback') && contains(fromJson('["add-changelog-codeowners", "add-changelog-file", "update-swagger-links"]'), inputs.operation)
        id: direct-commit
        continue-on-error: true
        run: |
          echo "üìù Attempting direct commit to ${{ inputs.default_branch }}..."
          
          git add .
          git commit -m "${{ env.commit_message }}

          Applied via project-admin workflow
          Repository: ${{ inputs.repository_name }}
          Operation: ${{ inputs.operation }}"
          
          if git push origin ${{ inputs.default_branch }}; then
            COMMIT_SHA=$(git rev-parse HEAD)
            echo "‚úÖ Direct commit successful"
            echo "commit_sha=$COMMIT_SHA" >> $GITHUB_ENV
            echo "action_taken=direct-commit" >> $GITHUB_ENV
            echo "details=${{ env.details }} (${COMMIT_SHA:0:7})" >> $GITHUB_ENV
            echo "direct_commit_success=true" >> $GITHUB_ENV
          else
            echo "‚ùå Direct commit failed"
            echo "direct_commit_success=false" >> $GITHUB_ENV
          fi

      - name: Handle Direct Commit Failure
        if: env.has_changes == 'true' && inputs.dry_run == false && steps.direct-commit.outcome == 'failure' && inputs.commit_strategy == 'direct-with-warning' && contains(fromJson('["add-changelog-codeowners", "add-changelog-file", "update-swagger-links"]'), inputs.operation)
        run: |
          echo "‚ö†Ô∏è Direct commit blocked (likely branch protection) - operation skipped"
          echo "result_type=warning" >> $GITHUB_ENV
          echo "action_taken=skipped" >> $GITHUB_ENV
          echo "details=Direct commit blocked by branch protection" >> $GITHUB_ENV

      - name: Create Pull Request
        if: env.has_changes == 'true' && inputs.dry_run == false && (inputs.commit_strategy == 'pull-request' || (inputs.commit_strategy == 'direct-with-pr-fallback' && env.direct_commit_success != 'true')) && contains(fromJson('["add-changelog-codeowners", "add-changelog-file", "update-swagger-links"]'), inputs.operation)
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.CAMARA_TOKEN }}
          script: |
            const [owner, repo] = '${{ inputs.repository_full_name }}'.split('/');
            const defaultBranch = '${{ inputs.default_branch }}';
            
            try {
              console.log('üîÑ Creating pull request...');
              
              // Get base commit SHA
              const branchResponse = await github.rest.repos.getBranch({
                owner: owner,
                repo: repo,
                branch: defaultBranch
              });
              const baseSha = branchResponse.data.commit.sha;
              
              // Create feature branch
              const timestamp = Date.now();
              const branchName = `camara-admin/${{ inputs.operation }}-${timestamp}`;
              
              await github.rest.git.createRef({
                owner: owner,
                repo: repo,
                ref: `refs/heads/${branchName}`,
                sha: baseSha
              });
              
              // Stage and commit changes on feature branch
              const { execSync } = require('child_process');
              
              execSync(`git checkout -b ${branchName}`, { stdio: 'inherit' });
              execSync('git add .', { stdio: 'inherit' });
              execSync(`git commit -m "${{ env.commit_message }}\n\nApplied via project-admin workflow\nRepository: ${{ inputs.repository_name }}\nOperation: ${{ inputs.operation }}"`, { stdio: 'inherit' });
              execSync(`git push origin ${branchName}`, { stdio: 'inherit' });
              
              // Get authenticated user for PR body personalization
              const authenticatedUser = await github.rest.users.getAuthenticated();
              const isBot = authenticatedUser.data.type === 'Bot' || 
                           authenticatedUser.data.login.includes('bot') ||
                           authenticatedUser.data.login.includes('admin');
              
              const prBodyFooter = isBot ? 
                `ü§ñ **Automated by ${authenticatedUser.data.name || authenticatedUser.data.login}**  
                Generated via project-admin workflow
                
                ---
                *If you have questions about this automated change, please contact the CAMARA project administrators.*` :
                `üîß **Generated via project-admin workflow**  
                Triggered by ${context.actor}
                
                ---
                *This is an automated administrative update.*`;
              
              // Create pull request
              const prResponse = await github.rest.pulls.create({
                owner: owner,
                repo: repo,
                title: process.env.pr_title,
                head: branchName,
                base: defaultBranch,
                body: `${process.env.pr_body}\n\n${prBodyFooter}`
              });
              
              console.log(`‚úÖ Pull request created: ${prResponse.data.html_url}`);
              core.exportVariable('action_taken', 'pull-request');
              core.exportVariable('details', `${{ env.details }} (PR #${prResponse.data.number})`);
              core.exportVariable('pr_number', prResponse.data.number);
              core.exportVariable('pr_url', prResponse.data.html_url);
              
            } catch (error) {
              core.setFailed(`‚ùå Failed to create pull request: ${error.message}`);
              core.exportVariable('result_type', 'error');
              core.exportVariable('action_taken', 'failed');
              core.exportVariable('details', `Failed to create pull request: ${error.message}`);
            }

      - name: Determine result metadata
        if: always()
        run: |
          # Set default values if not already set by operation steps
          RESULT_TYPE="${{ env.result_type }}"
          DETAILS="${{ env.details }}"
          ACTION_TAKEN="${{ env.action_taken }}"
          OPERATION_STATUS="${{ env.operation_status }}"
          
          # Handle case where operation failed before setting result variables
          if [ -z "$RESULT_TYPE" ]; then
            if [ "${{ job.status }}" = "failure" ]; then
              RESULT_TYPE="error"
              DETAILS="Operation failed with error"
              ACTION_TAKEN="failed"
              OPERATION_STATUS="job-failed"
            else
              RESULT_TYPE="unknown"
              DETAILS="Operation completed with unknown status"
              ACTION_TAKEN="unknown"
              OPERATION_STATUS="unknown"
            fi
          fi
          
          # Export final values
          echo "FINAL_RESULT_TYPE=$RESULT_TYPE" >> $GITHUB_ENV
          echo "FINAL_DETAILS=$DETAILS" >> $GITHUB_ENV
          echo "FINAL_ACTION_TAKEN=$ACTION_TAKEN" >> $GITHUB_ENV
          echo "FINAL_OPERATION_STATUS=$OPERATION_STATUS" >> $GITHUB_ENV
          
          echo "Result metadata determined:"
          echo "  Result Type: $RESULT_TYPE"
          echo "  Details: $DETAILS"
          echo "  Action Taken: $ACTION_TAKEN"
          echo "  Operation Status: $OPERATION_STATUS"

      - name: Create result file for collection
        if: always()
        run: |
          mkdir -p /tmp/results
          
          # Handle potentially empty environment variables
          PR_NUMBER="${{ env.pr_number }}"
          PR_URL="${{ env.pr_url }}"
          COMMIT_SHA="${{ env.commit_sha }}"
          
          cat > /tmp/results/result-${{ inputs.repository_name }}.json << EOF
          {
            "repository": "${{ inputs.repository_name }}",
            "operation": "${{ inputs.operation }}",
            "result_type": "${{ env.FINAL_RESULT_TYPE }}",
            "details": "${{ env.FINAL_DETAILS }}",
            "operation_status": "${{ env.FINAL_OPERATION_STATUS }}",
            "action_taken": "${{ env.FINAL_ACTION_TAKEN }}",
            "dry_run": ${{ inputs.dry_run }},
            "commit_strategy": "${{ inputs.commit_strategy }}",
            "pr_number": "${PR_NUMBER:-}",
            "pr_url": "${PR_URL:-}",
            "commit_sha": "${COMMIT_SHA:-}",
            "timestamp": "$(date -u +%Y-%m-%dT%H:%M:%SZ)"
          }
          EOF

      - name: Upload result artifact
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: result-${{ inputs.repository_name }}
          path: /tmp/results/result-${{ inputs.repository_name }}.json
          retention-days: 1

      - name: Create summary
        run: |
          case "${{ env.FINAL_RESULT_TYPE }}" in
            "success") DISPLAY_EMOJI="‚úÖ" ;;
            "no-change") DISPLAY_EMOJI="üìä" ;;
            "warning") DISPLAY_EMOJI="‚ö†Ô∏è" ;;
            "would-action") DISPLAY_EMOJI="üß™" ;;
            "error") DISPLAY_EMOJI="‚ùå" ;;
            *) DISPLAY_EMOJI="‚ùì" ;;
          esac
          
          echo "## Repository: ${{ inputs.repository_name }}" >> $GITHUB_STEP_SUMMARY
          echo "**Operation**: ${{ inputs.operation }}" >> $GITHUB_STEP_SUMMARY
          echo "**Result**: $DISPLAY_EMOJI ${{ env.FINAL_RESULT_TYPE }}" >> $GITHUB_STEP_SUMMARY
          echo "**Details**: ${{ env.FINAL_DETAILS }}" >> $GITHUB_STEP_SUMMARY
          echo "**Action Taken**: ${{ env.FINAL_ACTION_TAKEN }}" >> $GITHUB_STEP_SUMMARY
          echo "**Dry Run**: ${{ inputs.dry_run }}" >> $GITHUB_STEP_SUMMARY
          echo "**Commit Strategy**: ${{ inputs.commit_strategy }}" >> $GITHUB_STEP_SUMMARY
          
          if [ -n "${{ env.pr_number }}" ]; then
            echo "**Pull Request**: #${{ env.pr_number }} - ${{ env.pr_url }}" >> $GITHUB_STEP_SUMMARY
          fi
          
          if [ -n "${{ env.commit_sha }}" ]; then
            echo "**Commit**: ${{ env.commit_sha }}" >> $GITHUB_STEP_SUMMARY
          fi
          
          if [[ "${{ env.FINAL_RESULT_TYPE }}" == "warning" || "${{ env.FINAL_RESULT_TYPE }}" == "error" ]]; then
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "‚ö†Ô∏è **This result requires attention**" >> $GITHUB_STEP_SUMMARY
          fi